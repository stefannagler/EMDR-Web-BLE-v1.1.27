<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMDR Speed Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            padding-top: 15vh;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
        }

        .title {
            text-align: center;
            color: white;
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .speed-test-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 200px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .speed-test-slider-group {
            flex: 1;
            min-width: 250px;
        }

        .speed-test-slider-group label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 12px;
            display: block;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .speed-test-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .speed-test-btn {
            padding: 14px 28px;
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.3), rgba(78, 205, 196, 0.1));
            border: 2px solid rgba(78, 205, 196, 0.6);
            border-radius: 16px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 140px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 6px 20px rgba(78, 205, 196, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .speed-test-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .speed-test-btn:hover::before {
            left: 100%;
        }

        .speed-test-btn:hover {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: #4ecdc4;
            transform: translateY(-3px);
            box-shadow: 
                0 8px 25px rgba(78, 205, 196, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .speed-test-btn:active {
            transform: translateY(-1px);
            box-shadow: 
                0 4px 15px rgba(78, 205, 196, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .speed-test-btn.running {
            background: linear-gradient(145deg, rgba(255, 107, 107, 0.3), rgba(255, 107, 107, 0.1));
            border-color: rgba(255, 107, 107, 0.6);
            color: #ff6b6b;
            box-shadow: 
                0 6px 20px rgba(255, 107, 107, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .speed-test-btn.running:hover {
            background: linear-gradient(145deg, rgba(255, 107, 107, 0.4), rgba(255, 107, 107, 0.2));
            border-color: #ff6b6b;
            box-shadow: 
                0 8px 25px rgba(255, 107, 107, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .speed-test-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Bouncy Ball Animation */
        .bouncy-ball-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            margin-top: 20px;
            margin-bottom: 0px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #infinity-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .size-controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bouncy-ball {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a52, #c44569);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: left 3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 2s ease;
            user-select: none;
            box-shadow: 
                0 6px 20px rgba(255, 107, 107, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .bouncy-ball.fading {
            opacity: 0 !important;
            transition: opacity 1.5s ease !important;
        }

        .bouncy-ball.returning {
            opacity: 0 !important;
            left: 0 !important;
            transition: left 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
        }

        .bouncy-ball.reappearing {
            opacity: 1 !important;
            transition: opacity 0.5s ease !important;
        }

        .bouncy-ball.stopping {
            background: radial-gradient(circle at 30% 30%, #ff9999, #ff7777, #ff5555) !important;
            box-shadow: 
                0 6px 20px rgba(255, 153, 153, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
            transition: background 0.5s ease, box-shadow 0.5s ease !important;
        }

        .bouncy-ball.animating {
            animation: bounceHorizontal var(--animation-duration, 2s) ease-in-out infinite;
            transition: none; /* Disable transition during animation */
        }

        .bouncy-ball.infinity {
            animation: infinityPath var(--animation-duration, 2s) ease-in-out infinite;
            transition: none; /* Disable transition during animation */
        }

        @keyframes bounceHorizontal {
            0% {
                left: 30px;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                left: calc(100% - 30px);
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                left: 30px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes bounceHorizontalStop {
            0% {
                left: var(--current-position, 0);
                transform: translateY(-50%) scale(1);
            }
            100% {
                left: 0;
                transform: translateY(-50%) scale(1);
            }
        }

        @keyframes infinityPath {
            0% {
                left: 50%;
                top: 40%;
                transform: translate(-50%, -50%) scale(1);
            }
            8.33% {
                left: 65%;
                top: 35%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            16.66% {
                left: 75%;
                top: 45%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            25% {
                left: 80%;
                top: 60%;
                transform: translate(-50%, -50%) scale(1.15);
            }
            33.33% {
                left: 75%;
                top: 75%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            41.66% {
                left: 65%;
                top: 80%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            50% {
                left: 50%;
                top: 85%;
                transform: translate(-50%, -50%) scale(1);
            }
            58.33% {
                left: 35%;
                top: 80%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            66.66% {
                left: 25%;
                top: 75%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            75% {
                left: 20%;
                top: 60%;
                transform: translate(-50%, -50%) scale(1.15);
            }
            83.33% {
                left: 25%;
                top: 45%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            91.66% {
                left: 35%;
                top: 35%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                left: 50%;
                top: 40%;
                transform: translate(-50%, -50%) scale(1);
            }
        }


        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .speed-test-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .speed-test-buttons {
                justify-content: center;
            }
            
            .bouncy-ball-container {
                height: 80px;
            }
            
            .bouncy-ball {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <button class="close-btn" onclick="window.close()" title="Close Tab">âœ•</button>
    
    <div class="container">
        <h1 class="title">âš¡ EMDR Speed Test</h1>
        
        <div class="speed-test-controls">
            <div class="speed-test-slider-group">
                <label>Animation Speed: <span id="speed-test-value">2.0</span>s</label>
                <input type="range" id="speed-test-slider" min="1.0" max="3.0" step="0.1" value="2.0" class="slider">
            </div>
                <div class="speed-test-buttons">
                    <button class="speed-test-btn" id="toggle-btn" onclick="toggleSpeedTest()">Start</button>
                    <button class="speed-test-btn" id="pattern-btn" onclick="togglePattern()">âˆž Pattern</button>
                    <button class="speed-test-btn" id="audio-btn" onclick="toggleAudio()">ðŸ”” Audio</button>
                </div>
                
                <div class="size-controls" id="size-controls" style="display: none;">
                    <div class="speed-test-slider-group">
                        <label>Width: <span id="widthValue">300</span></label>
                        <input type="range" id="widthSlider" min="300" max="800" value="300" class="slider">
                    </div>
                    <div class="speed-test-slider-group">
                        <label>Height: <span id="heightValue">150</span></label>
                        <input type="range" id="heightSlider" min="150" max="500" value="150" class="slider">
                    </div>
                </div>
        </div>
        
        <div class="bouncy-ball-container">
            <canvas id="infinity-canvas"></canvas>
        </div>
        
    </div>

    <script>
        // Speed Test State
        let speedTestState = {
            isRunning: false,
            animationSpeed: 2.0,
            stopRequested: false,
            isInfinityPattern: false,
            audioEnabled: false,
            audioVolume: 0.5
        };

        // Animated Infinity Class
        class AnimatedInfinity {
            constructor(canvasId, options = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas size to match container
                this.resizeCanvas();
                
                this.centerX = options.centerX || this.canvas.width / 2;
                this.centerY = options.centerY || this.canvas.height / 2;
                this.size = options.size || Math.min(this.canvas.width, this.canvas.height) * 0.6; // Much bigger infinity loop
                this.width = options.width || 120; // Width of infinity loop
                this.height = options.height || 60; // Height of infinity loop
                this.speed = options.speed || 0.015; // Constant speed
                this.time = 0;
                this.isRunning = false;
                this.stopRequested = false;
                this.ballColor = '#ff6b6b';
                this.pathColor = 'rgba(255, 255, 255, 0.2)';
                
                // Audio tracking for infinity pattern
                this.lastXPosition = 0; // Track last time for phase detection
                
                this.animate = this.animate.bind(this);
                
                // Handle window resize
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.size = Math.min(this.canvas.width, this.canvas.height) * 0.6; // Much bigger infinity loop
            }
            
            getPointOnPath(t) {
                const scaledT = t * Math.PI * 2;
                const x = this.centerX + this.width * Math.cos(scaledT) / (1 + Math.sin(scaledT) * Math.sin(scaledT));
                const y = this.centerY + this.height * Math.sin(scaledT) * Math.cos(scaledT) / (1 + Math.sin(scaledT) * Math.sin(scaledT));
                return { x, y };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw full infinity path
                this.ctx.beginPath();
                for (let t = 0; t <= 1; t += 0.01) {
                    const point = this.getPointOnPath(t);
                    if (t === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                this.ctx.strokeStyle = this.pathColor;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Draw moving ball
                const currentPoint = this.getPointOnPath(this.time);
                this.ctx.beginPath();
                this.ctx.arc(currentPoint.x, currentPoint.y, 18, 0, Math.PI * 2); // Larger ball
                
                // Create gradient for 3D ball effect
                const gradient = this.ctx.createRadialGradient(
                    currentPoint.x - 6, currentPoint.y - 6, 0,
                    currentPoint.x, currentPoint.y, 18
                );
                gradient.addColorStop(0, '#ff9999');
                gradient.addColorStop(0.6, this.ballColor);
                gradient.addColorStop(1, '#c44569');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // Add shadow
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                this.ctx.shadowBlur = 8;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;
                this.ctx.fill();
                this.ctx.shadowColor = 'transparent';
            }
            
            start() {
                this.isRunning = true;
                this.stopRequested = false;
                this.lastTime = null; // Reset time tracking
                this.animate(performance.now());
            }
            
            stop() {
                this.stopRequested = true;
            }
            
            setBallColor(color) {
                this.ballColor = color;
            }
            
            setSize(newSize) {
                this.size = newSize;
            }
            
            scaleSize(factor) {
                this.size *= factor;
            }
            
            getSize() {
                return this.size;
            }
            
            setWidth(newWidth) {
                this.width = newWidth;
                this.draw(); // Redraw immediately to show changes
            }
            
            setHeight(newHeight) {
                this.height = newHeight;
                this.draw(); // Redraw immediately to show changes
            }
            
            getDimensions() {
                return { width: this.width, height: this.height };
            }
            
            animate(currentTime) {
                if (!this.isRunning) {
                    console.log('Infinity animation not running, exiting');
                    return;
                }
                
                // Time-based animation instead of frame-based
                if (!this.lastTime) this.lastTime = currentTime;
                const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;
                
                // Update time based on actual elapsed time, not frames
                this.time += this.speed * deltaTime;
                
                // Audio triggers for infinity pattern - based on time phases
                // Time 0.0: Ball starts on RIGHT
                // Time 0.5: Ball is on LEFT
                // Time 1.0: Ball returns to RIGHT
                
                // Left trigger: when ball reaches left side (time crosses 0.5)
                if (this.time >= 0.5 && this.lastXPosition < 0.5) {
                    playLeftBell(); // Play left bell when ball is on left side
                }
                // Right trigger: when ball reaches right side (time crosses 1.0, which wraps to 0.0)
                if (this.time >= 1.0 && this.lastXPosition < 1.0) {
                    playRightBell(); // Play right bell when ball returns to right side
                }
                
                // Update tracking for next frame
                this.lastXPosition = this.time;
                
                if (this.time >= 1) {
                    console.log('Infinity: Cycle complete, stopRequested:', this.stopRequested);
                    if (this.stopRequested) {
                        this.isRunning = false;
                        this.stopRequested = false;
                        this.time = 0;
                        
                        // IMPORTANT: Update global state
                        speedTestState.isRunning = false;
                        speedTestState.stopRequested = false;
                        
                        // Reset button text and class
                        const toggleBtn = document.getElementById('toggle-btn');
                        if (toggleBtn) {
                            toggleBtn.textContent = 'Start';
                            toggleBtn.classList.remove('running');
                            toggleBtn.disabled = false; // Re-enable button
                        }
                        
                        return;
                    }
                    this.time = 0;
                    // Reset audio tracking for next cycle
                    this.lastXPosition = 0; // Start at time 0
                }
                
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        // Tibetan Bell Audio System with Stereo Channels
        function createTibetanBellSound(frequency = 800, duration = 2000, channel = 'both') {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const pannerNode = audioContext.createStereoPanner();
            
            // Connect nodes: oscillator -> gain -> panner -> destination
            oscillator.connect(gainNode);
            gainNode.connect(pannerNode);
            pannerNode.connect(audioContext.destination);
            
            // Set frequency and type for bell-like sound
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            // Set stereo panning
            if (channel === 'left') {
                pannerNode.pan.setValueAtTime(-1, audioContext.currentTime); // Full left
            } else if (channel === 'right') {
                pannerNode.pan.setValueAtTime(1, audioContext.currentTime); // Full right
            } else {
                pannerNode.pan.setValueAtTime(0, audioContext.currentTime); // Center
            }
            
            // Create bell-like envelope (quick attack, slow decay)
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(speedTestState.audioVolume * 0.8, now + 0.01); // Quick attack
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration / 1000); // Slow decay
            
            // Start and stop
            oscillator.start(now);
            oscillator.stop(now + duration / 1000);
        }

        function playLeftBell() {
            if (speedTestState.audioEnabled) {
                // Lower frequency for left ear, played in left channel
                createTibetanBellSound(600, 300, 'left');
                console.log('ðŸ”” Left bell sound played (left channel)');
            }
        }

        function playRightBell() {
            if (speedTestState.audioEnabled) {
                // Higher frequency for right ear, played in right channel
                createTibetanBellSound(1000, 300, 'right');
                console.log('ðŸ”” Right bell sound played (right channel)');
            }
        }

        // Global variables
        let infinityAnimation = null;
        let horizontalAnimation = null;
        
        // Horizontal animation state
        let horizontalBallColor = '#ff6b6b';
        let horizontalIsStopping = false;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize infinity animation
            infinityAnimation = new AnimatedInfinity('infinity-canvas', {
                speed: 1.0 / speedTestState.animationSpeed, // cycles per second
                size: 60, // Match the size slider default
                width: 300, // Match the width slider default
                height: 150 // Match the height slider default
            });
            
            // Don't draw infinity pattern on startup since we start in horizontal mode
            // Draw initial horizontal ball at start position
            drawHorizontalBallAtStart();
            // Get speed from URL parameter if available
            const urlParams = new URLSearchParams(window.location.search);
            const speedParam = urlParams.get('speed');
            if (speedParam) {
                const urlSpeed = parseFloat(speedParam);
                speedTestState.animationSpeed = urlSpeed;
                const slider = document.getElementById('speed-test-slider');
                const valueDisplay = document.getElementById('speed-test-value');
                if (slider && valueDisplay) {
                    // Set slider to match the URL speed parameter directly
                    slider.value = urlSpeed.toFixed(1);
                    valueDisplay.textContent = speedParam;
                }
            }
            
            setupSpeedTestSlider();
            setupSizeControls();
        });

        function setupSpeedTestSlider() {
            const slider = document.getElementById('speed-test-slider');
            const valueDisplay = document.getElementById('speed-test-value');
            
            if (slider && valueDisplay) {
                slider.addEventListener('input', function() {
                    // Direct calculation: slider value = actual seconds
                    const sliderValue = parseFloat(this.value);
                    speedTestState.animationSpeed = sliderValue; // Direct mapping: 1.0=1 second, 2.0=2 seconds, 3.0=3 seconds
                    valueDisplay.textContent = speedTestState.animationSpeed.toFixed(1);
                    
                    // Update animation speed if currently running
                    if (speedTestState.isRunning) {
                        if (speedTestState.isInfinityPattern && infinityAnimation) {
                            // Convert slider to cycles per second: 1.0=1 second cycle, 2.0=2 second cycle, 3.0=3 second cycle
                            infinityAnimation.speed = 1.0 / speedTestState.animationSpeed; // cycles per second
                        }
                        // For horizontal animation, speed is calculated dynamically in the animation loop
                    }
                });
            }
        }

        function setupSizeControls() {
            const widthSlider = document.getElementById('widthSlider');
            const heightSlider = document.getElementById('heightSlider');
            const widthValue = document.getElementById('widthValue');
            const heightValue = document.getElementById('heightValue');
            
            // Width controls
            if (widthSlider && widthValue) {
                widthSlider.addEventListener('input', (e) => {
                    const newWidth = parseInt(e.target.value);
                    if (infinityAnimation) {
                        infinityAnimation.setWidth(newWidth);
                    }
                    widthValue.textContent = newWidth;
                });
            }
            
            // Height controls
            if (heightSlider && heightValue) {
                heightSlider.addEventListener('input', (e) => {
                    const newHeight = parseInt(e.target.value);
                    if (infinityAnimation) {
                        infinityAnimation.setHeight(newHeight);
                    }
                    heightValue.textContent = newHeight;
                });
            }
        }

        function toggleSpeedTest() {
            const toggleBtn = document.getElementById('toggle-btn');
            
            console.log('toggleSpeedTest called, isRunning:', speedTestState.isRunning, 'isInfinityPattern:', speedTestState.isInfinityPattern, 'button found:', !!toggleBtn);
            
            if (!toggleBtn || !infinityAnimation) return;
            
            if (speedTestState.isRunning) {
                // Request stop and let animations handle their own stopping
                speedTestState.stopRequested = true;
                toggleBtn.textContent = 'Stopping...';
                toggleBtn.disabled = true; // Disable button during stopping
                
                // Stop animations and reset positions
                if (speedTestState.isInfinityPattern) {
                    infinityAnimation.setBallColor('#ff9999'); // Change to lighter red for stopping
                    infinityAnimation.stop(); // Request smooth stop at end of cycle
                } else {
                    // For horizontal, request smooth stop instead of immediate stop
                    horizontalBallColor = '#ff9999'; // Change to lighter red for stopping
                    // Don't call stopHorizontalAnimation() - let it do smooth return
                }
                
            } else {
                console.log('Starting animation, isInfinityPattern:', speedTestState.isInfinityPattern);
                // Start the animation
                speedTestState.isRunning = true;
                speedTestState.stopRequested = false;
                
                // Reset ball color
                infinityAnimation.setBallColor('#ff6b6b');
                
                if (speedTestState.isInfinityPattern) {
                    console.log('Starting INFINITY pattern with speed:', speedTestState.animationSpeed);
                    // Update speed based on slider for infinity pattern (actual seconds)
                    infinityAnimation.speed = 1.0 / speedTestState.animationSpeed; // cycles per second
                    infinityAnimation.start();
                } else {
                    console.log('Starting HORIZONTAL pattern with speed:', speedTestState.animationSpeed);
                    // Reset horizontal ball color and stopping state
                    horizontalBallColor = '#ff6b6b';
                    horizontalIsStopping = false;
                    startHorizontalAnimation();
                }
                
                // Update button state
                toggleBtn.classList.add('running');
                toggleBtn.textContent = 'Stop';
            }
        }

        // Monitor animation cycles to stop at start position
        function checkForStopAtStart() {
            const ball = document.getElementById('bouncy-ball');
            const toggleBtn = document.getElementById('toggle-btn');
            
            if (!ball || !speedTestState.isRunning || !speedTestState.stopRequested) return;
            
            // Get current position
            const ballRect = ball.getBoundingClientRect();
            const containerRect = ball.parentElement.getBoundingClientRect();
            const currentLeft = ballRect.left - containerRect.left;
            const currentTop = ballRect.top - containerRect.top;
            
            let shouldStop = false;
            
            if (speedTestState.isInfinityPattern) {
                // For infinity pattern, stop when ball is near the starting position (top of infinity)
                // Check if ball is near the starting position (50% left, 40% top)
                const startLeft = containerRect.width * 0.5;
                const startTop = containerRect.height * 0.4;
                const distanceFromStart = Math.sqrt(
                    Math.pow(currentLeft - startLeft, 2) + Math.pow(currentTop - startTop, 2)
                );
                shouldStop = distanceFromStart < 40; // Within 40px of start position
            } else {
                // For horizontal pattern, stop when ball is near left edge
                shouldStop = currentLeft < 40; // Adjusted for new positioning
            }
            
            if (shouldStop) {
                speedTestState.isRunning = false;
                speedTestState.stopRequested = false;
                
                ball.classList.remove('animating', 'infinity', 'stopping');
                ball.style.setProperty('--animation-duration', '');
                
                // Reset to appropriate start position
                if (speedTestState.isInfinityPattern) {
                    ball.style.left = '50%';
                    ball.style.top = '40%';
                } else {
                    ball.style.left = '30px';
                    ball.style.top = '50%';
                }
                
                // Update button state
                toggleBtn.classList.remove('running');
                toggleBtn.textContent = 'Start';
                toggleBtn.disabled = false; // Re-enable button
            }
        }

        // Check for stop condition every 100ms during animation
        let animationCheckInterval = null;
        
        function startAnimationCheck() {
            if (animationCheckInterval) clearInterval(animationCheckInterval);
            animationCheckInterval = setInterval(checkForStopAtStart, 100);
        }
        
        function stopAnimationCheck() {
            if (animationCheckInterval) {
                clearInterval(animationCheckInterval);
                animationCheckInterval = null;
            }
        }

        function togglePattern() {
            const patternBtn = document.getElementById('pattern-btn');
            
            if (!patternBtn) return;
            
            // Toggle pattern
            speedTestState.isInfinityPattern = !speedTestState.isInfinityPattern;
            
            // Update button text and style
            if (speedTestState.isInfinityPattern) {
                patternBtn.textContent = 'â†” Pattern';
                patternBtn.classList.add('running');
                // Show size controls for infinity pattern
                document.getElementById('size-controls').style.display = 'block';
            } else {
                patternBtn.textContent = 'âˆž Pattern';
                patternBtn.classList.remove('running');
                // Hide size controls for horizontal pattern
                document.getElementById('size-controls').style.display = 'none';
            }
            
            // If animation is running, restart it with new pattern
            if (speedTestState.isRunning) {
                if (speedTestState.isInfinityPattern) {
                    // Switch to infinity pattern with current speed (actual seconds)
                    stopHorizontalAnimation();
                    infinityAnimation.speed = 1.0 / speedTestState.animationSpeed; // cycles per second
                    infinityAnimation.start();
                } else {
                    // Switch to horizontal pattern
                    infinityAnimation.stop();
                    // Clear the infinity pattern from screen
                    drawHorizontalBallAtStart();
                    startHorizontalAnimation();
                }
            } else {
                // If animation is not running, just update the display
                if (speedTestState.isInfinityPattern) {
                    // Show infinity pattern
                    infinityAnimation.draw();
                } else {
                    // Show horizontal ball at start position
                    drawHorizontalBallAtStart();
                }
            }
        }

        function toggleAudio() {
            speedTestState.audioEnabled = !speedTestState.audioEnabled;
            const audioBtn = document.getElementById('audio-btn');
            if (audioBtn) {
                if (speedTestState.audioEnabled) {
                    audioBtn.classList.add('running');
                    audioBtn.textContent = 'ðŸ”Š Audio';
                    console.log('ðŸ”Š Audio enabled - Tibetan bells will play for left/right movement');
                } else {
                    audioBtn.classList.remove('running');
                    audioBtn.textContent = 'ðŸ”” Audio';
                    console.log('ðŸ”‡ Audio disabled');
                }
            }
        }

        function startHorizontalAnimation() {
            console.log('ðŸš€ Starting horizontal animation function');
            // Create a simple horizontal animation using canvas
            const canvas = document.getElementById('infinity-canvas');
            const ctx = canvas.getContext('2d');
            
            let position = 0;
            let direction = 1;
            const ballRadius = 18; // Larger ball to match infinity pattern
            // Initial speed will be calculated in the animate function based on slider value
            
            let lastTime = null;
            
            function animate(currentTime) {
                if (!speedTestState.isRunning || speedTestState.isInfinityPattern) {
                    if (!speedTestState.isRunning) console.log('Horizontal: Animation not running, exiting');
                    if (speedTestState.isInfinityPattern) console.log('Horizontal: Infinity pattern selected, exiting');
                    return;
                }
                
                // Debug: Log position and stopRequested status every 60 frames (roughly once per second)
                if (Math.floor(currentTime / 1000) !== Math.floor((currentTime - 16) / 1000)) {
                    console.log('Horizontal: Position:', position, 'stopRequested:', speedTestState.stopRequested, 'direction:', direction);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Time-based animation instead of frame-based
                if (!lastTime) lastTime = currentTime;
                const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
                lastTime = currentTime;
                
                // Update speed from current state (convert seconds to pixels per second)
                const slider = document.getElementById('speed-test-slider');
                const sliderValue = parseFloat(slider.value);
                // Convert slider to actual seconds: 1.0=1 second, 2.0=2 seconds, 3.0=3 seconds
                // For a full cycle (there and back), we need to travel canvas width twice
                const canvasWidth = canvas.width;
                const totalDistance = canvasWidth * 2; // There and back
                // Calculate pixels per second to complete cycle in specified seconds
                const pixelsPerSecond = totalDistance / sliderValue; // Total distance / seconds
                const pixelsPerFrame = pixelsPerSecond * deltaTime; // Convert to pixels per frame based on deltaTime
                speed = pixelsPerFrame;
                
                // Update position
                position += direction * speed;
                
                // Bounce off edges
                if (position >= canvas.width - ballRadius) {
                    position = canvas.width - ballRadius;
                    if (direction === 1) {
                        direction = -1;
                        playRightBell(); // Play right bell when bouncing off right edge (moving left)
                    }
                } else if (position <= ballRadius) {
                    position = ballRadius;
                    if (direction === -1) {
                        direction = 1;
                        playLeftBell(); // Play left bell when bouncing off left edge (moving right)
                    }
                }
                
                // Check if we should stop (when stop is requested and ball is near left edge)
                if (speedTestState.stopRequested && position <= ballRadius + 20 && direction === -1) {
                    // Stop when moving left and near start position
                    position = ballRadius; // Ensure we're exactly at start
                    horizontalIsStopping = false;
                    horizontalBallColor = '#ff6b6b'; // Reset to normal color
                    
                    // Draw ball at final position before stopping
                    ctx.beginPath();
                    ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                    
                    // Create gradient for 3D ball effect
                    const gradient = ctx.createRadialGradient(
                        position - 6, canvas.height / 2 - 6, 0,
                        position, canvas.height / 2, ballRadius
                    );
                    gradient.addColorStop(0, '#ff9999');
                    gradient.addColorStop(0.6, horizontalBallColor);
                    gradient.addColorStop(1, '#c44569');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Add shadow
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    
                    ctx.beginPath();
                    ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // IMPORTANT: Reset global state
                    speedTestState.isRunning = false;
                    speedTestState.stopRequested = false;
                    
                    // Reset button text and class
                    const toggleBtn = document.getElementById('toggle-btn');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'Start';
                        toggleBtn.classList.remove('running');
                        toggleBtn.disabled = false; // Re-enable button
                    }
                    
                    return; // Stop the animation
                }
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                
                // Create gradient for 3D ball effect
                const gradient = ctx.createRadialGradient(
                    position - 6, canvas.height / 2 - 6, 0,
                    position, canvas.height / 2, ballRadius
                );
                gradient.addColorStop(0, horizontalIsStopping ? '#ffaaaa' : '#ff9999');
                gradient.addColorStop(0.6, horizontalBallColor);
                gradient.addColorStop(1, horizontalIsStopping ? '#ff8888' : '#c44569');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fill();
                ctx.shadowColor = 'transparent';
                
                horizontalAnimation = requestAnimationFrame(animate);
            }
            
            console.log('ðŸŽ¬ Starting horizontal animate loop');
            animate(performance.now());
        }

        function stopHorizontalAnimation() {
            if (horizontalAnimation) {
                cancelAnimationFrame(horizontalAnimation);
                horizontalAnimation = null;
            }
        }

        function drawHorizontalBallAtStart() {
            // Draw horizontal ball at start position (left edge)
            const canvas = document.getElementById('infinity-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const ballRadius = 18; // Match the radius used in horizontal animation
            const position = ballRadius; // Start position at left edge
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ball at start position
            ctx.beginPath();
            ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
            
            // Create gradient for 3D ball effect (same as horizontal animation)
            const gradient = ctx.createRadialGradient(
                position - 6, canvas.height / 2 - 6, 0,
                position, canvas.height / 2, ballRadius
            );
            gradient.addColorStop(0, '#ff9999');
            gradient.addColorStop(0.6, '#ff6b6b');
            gradient.addColorStop(1, '#c44569');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
            
            ctx.beginPath();
            ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                toggleSpeedTest();
            } else if (event.code === 'Escape') {
                window.close();
            }
        });

        // Handle window close
        window.addEventListener('beforeunload', function() {
            stopAnimationCheck();
            if (speedTestState.isRunning) {
                speedTestState.isRunning = false;
                speedTestState.stopRequested = false;
            }
        });
    </script>
</body>
</html>
