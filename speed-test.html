<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMDR Speed Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        /* Fixed Header with Navigation */
        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            border-bottom: 1px solid #d1d1d1;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            padding: 0;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .app-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
        }

        .nav-menu {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .nav-item {
            padding: 8px 16px;
            color: #666;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .nav-item:hover {
            background: #f0f0f0;
            color: #333;
        }

        .nav-item.active {
            background: #e6f2ff;
            color: #4a90e2;
        }

        .close-tab-btn {
            background: #f0f0f0;
            border: 1px solid #d1d1d1;
            border-radius: 6px;
            color: #333;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .close-tab-btn:hover {
            background: #e0e0e0;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 10px;
            padding-top: 80px;
        }

        /* Content sections */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        .section-container {
            background: #ffffff;
            border: 1px solid #d1d1d1;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            border-bottom: 1px solid #d1d1d1;
            padding-bottom: 12px;
        }

        .speed-test-controls {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 12px;
            flex-wrap: wrap;
            gap: 40px;
            border: 1px solid #e0e0e0;
        }

        .speed-test-slider-group {
            flex: 0 0 300px; /* Fixed width, no grow/shrink */
        }

        .speed-test-slider-group label {
            color: #333;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 12px;
            display: block;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #d1d1d1;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
            border: 1px solid #999;
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
            border: 1px solid #999;
        }

        .speed-test-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .speed-test-btn {
            padding: 12px 24px;
            background: #4a90e2;
            border: 1px solid #4a90e2;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 120px;
        }

        .speed-test-btn:hover {
            background: #3a7bc8;
            border-color: #3a7bc8;
        }

        .speed-test-btn:active {
            background: #2d5aa0;
        }

        .speed-test-btn.running {
            background: #ff6b6b;
            border-color: #ff6b6b;
        }

        .speed-test-btn.running:hover {
            background: #e55a5a;
            border-color: #e55a5a;
        }

        .speed-test-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Google-style Toggle Switches */
        .toggle-switch {
            position: relative;
            width: 54px;
            height: 28px;
            border-radius: 14px;
            background: #bdbdbd;
            border: none;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
            z-index: 100;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .toggle-switch.active {
            background: #34c759 !important;
            border: 2px solid #28a745 !important;
        }


        /* Real element slider instead of ::after pseudo-element */
        .toggle-slider {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            border: none;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: #f5f5f5;
            transition: all 0.3s cubic-bezier(0, 0, 0.2, 1);
            pointer-events: none;
            will-change: transform;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(26px) !important;
            background: #ffffff;
        }
        
        /* Keep ::after for backwards compatibility with toggles that don't have .toggle-slider */
        .toggle-switch:not(:has(.toggle-slider))::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            border: none;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: #f5f5f5;
            transition: all 0.3s cubic-bezier(0, 0, 0.2, 1);
        }

        .toggle-switch:not(:has(.toggle-slider)).active::after {
            transform: translateX(26px);
            background: #ffffff;
        }

        /* iOS Style Toggle (for audio) */
        .toggle-switch.ios-style {
            width: 51px;
            height: 31px;
            border-radius: 16px;
            background: #e9e9ea;
            border: none;
            box-shadow: none;
        }

        .toggle-switch.ios-style.active {
            background: #34c759 !important;
            border: none !important;
        }

        /* iOS style slider element */
        .toggle-switch.ios-style .toggle-slider {
            width: 27px;
            height: 27px;
            top: 2px;
            left: 2px;
            background: #ffffff;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15), 0 3px 1px rgba(0, 0, 0, 0.06);
        }

        .toggle-switch.ios-style.active .toggle-slider {
            transform: translateX(20px) !important;
            background: #ffffff;
        }

        /* Keep ::after for backwards compatibility with iOS toggles without slider */
        .toggle-switch.ios-style:not(:has(.toggle-slider))::after {
            width: 27px;
            height: 27px;
            top: 2px;
            left: 2px;
            background: #ffffff;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15), 0 3px 1px rgba(0, 0, 0, 0.06);
        }

        .toggle-switch.ios-style:not(:has(.toggle-slider)).active::after {
            transform: translateX(20px);
        }

        /* Checkbox Style Toggle (for infinity line) - now uses standard toggle appearance */
        .toggle-switch.checkbox-style {
            width: 54px;
            height: 28px;
            border-radius: 14px;
            background: #bdbdbd;
            border: 2px solid #9e9e9e;
            box-shadow: none;
        }

        .toggle-switch.checkbox-style.active {
            background: #4a90e2 !important;
            border: 2px solid #3a7bc8 !important;
        }

        /* Checkbox style uses the slider element like other toggles */
        .toggle-switch.checkbox-style .toggle-slider {
            background: #f5f5f5;
        }

        .toggle-switch.checkbox-style.active .toggle-slider {
            transform: translateX(26px) !important;
            background: #ffffff;
        }

        /* Keep old checkbox styles for backwards compatibility with toggles without slider */
        .toggle-switch.checkbox-style:not(:has(.toggle-slider))::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: auto;
            height: auto;
            background: transparent;
            box-shadow: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s ease;
        }

        .toggle-switch.checkbox-style:not(:has(.toggle-slider)).active::after {
            transform: translate(-50%, -50%) scale(1);
        }

        /* For checkbox style without slider, make it square */
        .toggle-switch.checkbox-style:not(:has(.toggle-slider)) {
            width: 24px;
            height: 24px;
            border-radius: 4px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            color: #333;
            font-weight: 500;
        }

        /* Dropdown Menu Styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-trigger {
            cursor: pointer;
            padding: 10px 15px;
            border-radius: 6px;
            transition: background-color 0.3s ease;
        }

        .dropdown-trigger:hover {
            background-color: rgba(74, 144, 226, 0.1);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            min-width: 300px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            border: 1px solid #d1d1d1;
            border-radius: 8px;
            z-index: 1000;
            padding: 20px;
            margin-top: 0px;
        }

        .dropdown:hover .dropdown-content,
        .dropdown-content:hover {
            display: block;
        }

        /* Bridge the gap between trigger and content */
        .dropdown::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            height: 5px;
            background: transparent;
            z-index: 999;
        }

        .dropdown-section {
            margin-bottom: 20px;
        }

        .dropdown-section:last-child {
            margin-bottom: 0;
        }

        .dropdown-section h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
        }

        .dropdown-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 8px 0;
        }

        .dropdown-control:last-child {
            margin-bottom: 0;
        }
        
        /* Settings group for visually grouping related controls */
        .settings-group {
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid rgba(78, 205, 196, 0.5);
            border-radius: 6px;
            padding: 10px 12px;
            margin: 8px 0;
        }
        
        .settings-group .dropdown-control:first-child {
            margin-top: 0;
        }
        
        .settings-group .dropdown-control:last-child {
            margin-bottom: 0;
        }

        .dropdown-control label {
            color: #333;
            font-size: 13px;
            font-weight: 500;
            margin-right: 10px;
            min-width: 120px;
        }

        .dropdown-control .slider {
            width: 100px;
            margin-left: 10px;
        }

        .dropdown-control .toggle-switch {
            margin-left: 10px;
        }

        .infinity-only {
            display: none;
        }

        .infinity-only.show {
            display: flex;
        }

        /* Bouncy Ball Animation */
        .bouncy-ball-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            margin-top: 20px;
            margin-bottom: 0px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #infinity-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .size-controls {
            display: flex;
            flex-direction: row;
            justify-content: flex-end;
            gap: 20px;
            margin-top: 0;
            padding: 0;
            background: none;
            border: none;
            height: auto;
            box-sizing: border-box;
        }
        
        .size-controls .speed-test-slider-group {
            flex: 0 0 120px; /* Fixed width for each slider */
        }

        .audio-freq-controls {
            display: flex;
            flex-direction: row;
            justify-content: flex-end;
            gap: 20px;
            margin-top: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 80px;
            align-items: center;
        }

        .audio-freq-controls .speed-test-slider-group {
            flex: 0 0 150px;
            min-width: 150px;
            text-align: center;
        }
        
        .line-toggle-btn {
            padding: 8px 12px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 40px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .line-toggle-btn:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }
        
        .line-toggle-btn.active {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        .audio-freq-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .audio-freq-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .audio-freq-btn.active {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        .random-audio-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .random-audio-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .random-audio-btn.active {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        .random-audio-controls {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .random-audio-controls .speed-test-slider-group {
            flex: 0 0 150px;
            min-width: 150px;
            text-align: center;
        }

        .random-height-btn {
            padding: 8px 12px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 40px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .random-height-btn:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }
        
        .random-height-btn.active {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        .size-toggle-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .size-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .size-toggle-btn.active {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        .bouncy-ball {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: #ff6b6b;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: left 3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 2s ease;
            user-select: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .bouncy-ball.fading {
            opacity: 0 !important;
            transition: opacity 1.5s ease !important;
        }

        .bouncy-ball.returning {
            opacity: 0 !important;
            left: 0 !important;
            transition: left 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
        }

        .bouncy-ball.reappearing {
            opacity: 1 !important;
            transition: opacity 0.5s ease !important;
        }

        .bouncy-ball.stopping {
            background: radial-gradient(circle at 30% 30%, #ff9999, #ff7777, #ff5555) !important;
            transition: background 0.5s ease !important;
        }

        .bouncy-ball.animating {
            animation: bounceHorizontal var(--animation-duration, 2s) ease-in-out infinite;
            transition: none; /* Disable transition during animation */
        }

        .bouncy-ball.infinity {
            animation: infinityPath var(--animation-duration, 2s) ease-in-out infinite;
            transition: none; /* Disable transition during animation */
        }

        @keyframes bounceHorizontal {
            0% {
                left: 30px;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                left: calc(100% - 30px);
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                left: 30px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes bounceHorizontalStop {
            0% {
                left: var(--current-position, 0);
                transform: translateY(-50%) scale(1);
            }
            100% {
                left: 0;
                transform: translateY(-50%) scale(1);
            }
        }

        @keyframes infinityPath {
            0% {
                left: 50%;
                top: 40%;
                transform: translate(-50%, -50%) scale(1);
            }
            8.33% {
                left: 65%;
                top: 35%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            16.66% {
                left: 75%;
                top: 45%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            25% {
                left: 80%;
                top: 60%;
                transform: translate(-50%, -50%) scale(1.15);
            }
            33.33% {
                left: 75%;
                top: 75%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            41.66% {
                left: 65%;
                top: 80%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            50% {
                left: 50%;
                top: 85%;
                transform: translate(-50%, -50%) scale(1);
            }
            58.33% {
                left: 35%;
                top: 80%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            66.66% {
                left: 25%;
                top: 75%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            75% {
                left: 20%;
                top: 60%;
                transform: translate(-50%, -50%) scale(1.15);
            }
            83.33% {
                left: 25%;
                top: 45%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            91.66% {
                left: 35%;
                top: 35%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                left: 50%;
                top: 40%;
                transform: translate(-50%, -50%) scale(1);
            }
        }


        .close-btn {
            position: fixed;
            top: 30px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @media (max-width: 600px) {
            .container {
                padding: 10px;
                margin: 0;
            }
            
            .title {
                font-size: 24px;
            }
            
            .speed-test-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .speed-test-buttons {
                justify-content: center;
            }
            
            .bouncy-ball-container {
                height: 80px;
            }
            
            .bouncy-ball {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <!-- Fixed Header with Navigation -->
    <div class="fixed-header">
        <div class="header-content">
            <div class="app-title">⚡ EMDR v1.Web.7</div>
            
            <nav class="nav-menu">
                <!-- Settings Dropdown -->
                <div class="nav-item dropdown">
                    <span class="dropdown-trigger">⚙️ Quick Settings</span>
                    <div class="dropdown-content">
                        <div class="dropdown-section">
                            <h4>🔔 Audio</h4>
                            <div class="dropdown-control">
                                <label>Audio</label>
                                <div class="toggle-switch ios-style" id="audio-toggle-main" onclick="toggleAudio()">
                                    <div class="toggle-slider"></div>
                                </div>
                            </div>
                            <div class="dropdown-control">
                                <label>L Sound: <span id="leftFreqValue-main">600</span> Hz</label>
                                <input type="range" id="leftFreqSlider-main" min="300" max="1000" step="10" value="600" class="slider">
                            </div>
                            <div class="dropdown-control">
                                <label>R Sound: <span id="rightFreqValue-main">800</span> Hz</label>
                                <input type="range" id="rightFreqSlider-main" min="300" max="1000" step="10" value="800" class="slider">
                            </div>
                            
                            <div class="settings-group">
                                <div class="dropdown-control">
                                    <label>Random Audio</label>
                                    <div class="toggle-switch ios-style" id="random-audio-toggle-main" onclick="toggleRandomAudio()">
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>
                                <div class="dropdown-control">
                                    <label>Audio Change Interval: <span id="randomIntervalValue-main">10</span>s</label>
                                    <input type="range" id="randomIntervalSlider-main" min="5" max="30" value="10" class="slider">
                                </div>
                                <div class="dropdown-control">
                                    <label>Variation: <span id="randomVariationValue-main">100</span>Hz</label>
                                    <input type="range" id="randomVariationSlider-main" min="50" max="200" value="100" class="slider">
                                </div>
                            </div>
                        </div>
                        
                        <div class="dropdown-section">
                            <h4>👁️ Infinity Settings</h4>
                            <div class="dropdown-control">
                                <label>Infinity Line</label>
                                <div class="toggle-switch ios-style" id="infinity-line-toggle-main" onclick="toggleInfinityLine()">
                                    <div class="toggle-slider"></div>
                                </div>
                            </div>
                            <div class="dropdown-control">
                                <label>Width: <span id="widthValue-main">650</span>px</label>
                                <input type="range" id="widthSlider-main" min="300" max="800" value="650" class="slider">
                            </div>
                            <div class="dropdown-control">
                                <label>Height: <span id="heightValue-main">500</span>px</label>
                                <input type="range" id="heightSlider-main" min="150" max="500" value="500" class="slider">
                            </div>
                            
                            <div class="settings-group">
                                <div class="dropdown-control">
                                    <label>Random Height</label>
                                    <div class="toggle-switch ios-style" id="random-height-toggle-main" onclick="toggleRandomHeight()">
                                        <div class="toggle-slider"></div>
                                    </div>
                                </div>
                                <div class="dropdown-control">
                                    <label>Random Change Interval: <span id="randomIntervalInfinityValue-main">10</span>s</label>
                                    <input type="range" id="randomIntervalInfinitySlider-main" min="5" max="30" value="10" class="slider">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </nav>
        </div>
    </div>
    
    <div class="container">
        
        <!-- Horizontal Mode Section -->
        <div id="horizontal-section" class="content-section active">
            <div class="section-container">
                <div class="section-title" id="horizontal-section-title">Horizontal Animation</div>
        
        <div class="speed-test-controls">
            <div class="speed-test-slider-group">
                <label>Animation Speed: <span id="speed-test-value">2.0</span>s</label>
                <input type="range" id="speed-test-slider" min="1.0" max="3.0" step="0.1" value="2.0" class="slider">
            </div>
                <div class="speed-test-buttons">
                    <button class="speed-test-btn" id="toggle-btn" onclick="toggleEmdrApp()">Start</button>
                    <button class="speed-test-btn" id="pattern-btn" onclick="togglePattern()">∞ Pattern</button>
                    <button class="speed-test-btn" id="audio-btn" onclick="toggleAudio()">Audio</button>
                </div>
        </div>
        
        <div class="bouncy-ball-container">
            <canvas id="infinity-canvas"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Infinity Mode Section -->
        <div id="infinity-section" class="content-section">
            <div class="section-container">
                <div class="section-title">Infinity Pattern</div>
                
                <div class="speed-test-controls">
                    <div class="speed-test-slider-group">
                        <label>Animation Speed: <span id="speed-test-value-infinity">2.0</span>s</label>
                        <input type="range" id="speed-test-slider-infinity" min="1.0" max="3.0" step="0.1" value="2.0" class="slider">
                    </div>
                    <div class="speed-test-buttons">
                        <button class="speed-test-btn" id="toggle-btn-infinity" onclick="toggleEmdrApp()">Start</button>
                        <button class="speed-test-btn" id="pattern-btn-infinity" onclick="togglePattern()">← Horizontal</button>
                        <button class="speed-test-btn" id="audio-btn-infinity" onclick="toggleAudio()">Audio</button>
                    </div>
                </div>
                
                <div class="bouncy-ball-container">
                    <canvas id="infinity-canvas-infinity"></canvas>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Navigation function
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Update navigation active state
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'auto' });
        }

        // Toggle switch functions for settings
        function toggleAudio() {
            console.log('toggleAudio called, current state:', emdrAppState.audioEnabled);
            emdrAppState.audioEnabled = !emdrAppState.audioEnabled;
            console.log('toggleAudio new state:', emdrAppState.audioEnabled);
            updateAllAudioToggles();
            saveSettings();
            console.log('Audio toggled to:', emdrAppState.audioEnabled);
        }

        function toggleInfinityLine() {
            emdrAppState.showInfinityLine = !emdrAppState.showInfinityLine;
            console.log('About to call updateAllInfinityLineToggles, state:', emdrAppState.showInfinityLine);
            updateAllInfinityLineToggles();
            saveSettings();
            console.log('Infinity line toggled to:', emdrAppState.showInfinityLine);
        }

        function toggleRandomAudio() {
            emdrAppState.randomAudioEnabled = !emdrAppState.randomAudioEnabled;
            updateAllRandomAudioToggles();
            if (emdrAppState.randomAudioEnabled) {
                // Store base frequencies when enabling random audio
                emdrAppState.baseLeftFrequency = emdrAppState.leftFrequency;
                emdrAppState.baseRightFrequency = emdrAppState.rightFrequency;
                startRandomFrequencyChanges();
            } else {
                stopRandomFrequencyChanges();
                // Restore base frequencies when disabling
                emdrAppState.leftFrequency = emdrAppState.baseLeftFrequency;
                emdrAppState.rightFrequency = emdrAppState.baseRightFrequency;
                updateAllFrequencyDisplays();
            }
            saveSettings();
            console.log('Random audio toggled to:', emdrAppState.randomAudioEnabled);
        }

        function toggleRandomHeight() {
            emdrAppState.randomHeightEnabled = !emdrAppState.randomHeightEnabled;
            updateAllRandomHeightToggles();
            if (emdrAppState.randomHeightEnabled) {
                // Store base height when enabling random height
                emdrAppState.baseInfinityHeight = emdrAppState.infinityHeight;
                startRandomHeightChanges();
            } else {
                stopRandomHeightChanges();
                // Restore base height when disabling
                emdrAppState.infinityHeight = emdrAppState.baseInfinityHeight;
                updateAllHeightDisplays();
                updateInfinityAnimation();
            }
            saveSettings();
            console.log('Random height toggled to:', emdrAppState.randomHeightEnabled);
        }

        // Update section title based on current pattern
        function updateSectionTitle() {
            const titleElement = document.getElementById('horizontal-section-title');
            if (titleElement) {
                titleElement.textContent = emdrAppState.isInfinityPattern ? 'Infinity Animation' : 'Horizontal Animation';
            }
        }

        // Setup dropdown controls
        function setupDropdownControls() {
            console.log('Setting up dropdown controls');
            
            // Setup dropdown sliders
            setupSliderWithSync('leftFreqSlider-main', 'leftFreqValue-main', (value) => {
                emdrAppState.leftFrequency = value;
                updateAllFrequencyDisplays();
                saveSettings();
            });
            
            setupSliderWithSync('rightFreqSlider-main', 'rightFreqValue-main', (value) => {
                emdrAppState.rightFrequency = value;
                updateAllFrequencyDisplays();
                saveSettings();
            });
            
            setupSliderWithSync('widthSlider-main', 'widthValue-main', (value) => {
                console.log('Width slider changed to:', value);
                emdrAppState.infinityWidth = value;
                updateAllWidthDisplays();
                updateInfinityAnimation();
                saveSettings();
            });
            
            setupSliderWithSync('heightSlider-main', 'heightValue-main', (value) => {
                emdrAppState.infinityHeight = value;
                updateAllHeightDisplays();
                updateInfinityAnimation();
                saveSettings();
            });
            
            // Setup random audio sliders in dropdown
            setupSliderWithSync('randomIntervalSlider-main', 'randomIntervalValue-main', (value) => {
                emdrAppState.randomInterval = value;
                updateAllRandomIntervalDisplays();
                saveSettings();
            });
            
            setupSliderWithSync('randomVariationSlider-main', 'randomVariationValue-main', (value) => {
                emdrAppState.randomVariation = value;
                updateAllRandomVariationDisplays();
                saveSettings();
            });
            
            // Setup random height infinity interval slider in dropdown
            setupSliderWithSync('randomIntervalInfinitySlider-main', 'randomIntervalInfinityValue-main', (value) => {
                emdrAppState.randomIntervalInfinity = value;
                updateAllRandomIntervalInfinityDisplays();
                saveSettings();
            });
            
            // Update dropdown visibility based on current pattern
            updateDropdownVisibility();
        }

        // Update dropdown visibility based on current pattern
        function updateDropdownVisibility() {
            const infinityOnlyControls = document.querySelectorAll('.infinity-only');
            infinityOnlyControls.forEach(control => {
                if (emdrAppState.isInfinityPattern) {
                    control.classList.add('show');
                } else {
                    control.classList.remove('show');
                }
            });
        }

        // Update all toggle switches to match state
        function updateAllAudioToggles() {
            console.log('updateAllAudioToggles called, audioEnabled:', emdrAppState.audioEnabled);
            
            // Update all audio toggles including dropdown
            const toggles = ['audio-toggle-main', 'audio-btn', 'audio-btn-infinity'];
            toggles.forEach(id => {
                const toggle = document.getElementById(id);
                if (toggle) {
                    // Check if it's a toggle switch or a button
                    if (toggle.classList.contains('toggle-switch')) {
                        // It's a toggle switch - just add/remove active class
                        if (emdrAppState.audioEnabled) {
                            toggle.classList.add('active');
                        } else {
                            toggle.classList.remove('active');
                        }
                    } else {
                        // It's a button - update its text content
                        if (emdrAppState.audioEnabled) {
                            toggle.classList.add('running');
                            if (toggle.textContent && !toggle.textContent.includes('ON')) {
                                toggle.textContent = toggle.textContent + ' ON';
                            }
                        } else {
                            toggle.classList.remove('running');
                            if (toggle.textContent && toggle.textContent.includes(' ON')) {
                                toggle.textContent = toggle.textContent.replace(' ON', '');
                            }
                        }
                    }
                }
            });
        }

        function updateAllInfinityLineToggles() {
            console.log('updateAllInfinityLineToggles called, showInfinityLine:', emdrAppState.showInfinityLine);
            
            // Update all infinity line toggles including dropdown
            const toggles = ['infinity-line-toggle-main', 'line-toggle-btn', 'line-toggle-btn-infinity'];
            toggles.forEach(id => {
                const toggle = document.getElementById(id);
                if (toggle) {
                    // Check if it's a toggle switch or a button
                    if (toggle.classList.contains('toggle-switch')) {
                        // It's a toggle switch - just add/remove active class
                        if (emdrAppState.showInfinityLine) {
                            toggle.classList.add('active');
                        } else {
                            toggle.classList.remove('active');
                        }
                    } else {
                        // It's a button - update its text content
                        if (emdrAppState.showInfinityLine) {
                            toggle.classList.add('active');
                            if (toggle.textContent && !toggle.textContent.includes('ON')) {
                                toggle.textContent = toggle.textContent + ' ON';
                            }
                        } else {
                            toggle.classList.remove('active');
                            if (toggle.textContent && toggle.textContent.includes(' ON')) {
                                toggle.textContent = toggle.textContent.replace(' ON', '');
                            }
                        }
                    }
                }
            });
        }

        function updateAllRandomAudioToggles() {
            const toggles = ['random-audio-toggle-main', 'random-audio-btn', 'random-audio-btn-infinity'];
            toggles.forEach(id => {
                const toggle = document.getElementById(id);
                if (toggle) {
                    // Check if it's a toggle switch or a button
                    if (toggle.classList.contains('toggle-switch')) {
                        // It's a toggle switch - just add/remove active class
                        if (emdrAppState.randomAudioEnabled) {
                            toggle.classList.add('active');
                        } else {
                            toggle.classList.remove('active');
                        }
                    } else {
                        // It's a button - update its text content
                        if (emdrAppState.randomAudioEnabled) {
                            toggle.classList.add('active');
                            if (toggle.textContent && !toggle.textContent.includes('ON')) {
                                toggle.textContent = '🎲 Random ON';
                            }
                        } else {
                            toggle.classList.remove('active');
                            if (toggle.textContent) {
                                toggle.textContent = '🎲 Random';
                            }
                        }
                    }
                }
            });
        }

        function updateAllRandomHeightToggles() {
            console.log('updateAllRandomHeightToggles called, randomHeightEnabled:', emdrAppState.randomHeightEnabled);
            const toggles = ['random-height-toggle-main', 'random-height-btn', 'random-height-btn-infinity'];
            toggles.forEach(id => {
                const toggle = document.getElementById(id);
                if (toggle) {
                    // Check if it's a toggle switch or a button
                    if (toggle.classList.contains('toggle-switch')) {
                        // It's a toggle switch - just add/remove active class
                        if (emdrAppState.randomHeightEnabled) {
                            toggle.classList.add('active');
                        } else {
                            toggle.classList.remove('active');
                        }
                    } else {
                        // It's a button - update its text content
                        if (emdrAppState.randomHeightEnabled) {
                            toggle.classList.add('active');
                            if (toggle.textContent && !toggle.textContent.includes('ON')) {
                                toggle.textContent = '📊 Height ON';
                            }
                        } else {
                            toggle.classList.remove('active');
                            if (toggle.textContent) {
                                toggle.textContent = '📊 Height';
                            }
                        }
                    }
                }
            });
        }

        // EMDR App State
        let emdrAppState = {
            isRunning: false,
            animationSpeed: 2.0,
            targetSpeed: 2.0, // Target speed for smooth transitions
            stopRequested: false,
            isInfinityPattern: false,
            audioEnabled: false,
            audioVolume: 0.5,
            showInfinityLine: true, // Show infinity line by default
            leftFrequency: 600,
            rightFrequency: 800,
            infinityWidth: 650,
            infinityHeight: 500,
            randomAudioEnabled: false,
            randomInterval: 10, // seconds between changes for horizontal
            randomIntervalInfinity: 10, // seconds between changes for infinity
            randomVariation: 100, // Hz variation range
            baseLeftFrequency: 600, // Original left frequency
            baseRightFrequency: 800, // Original right frequency
            randomHeightEnabled: false,
            baseInfinityHeight: 500 // Original infinity height
        };

        // Load settings from localStorage
        function loadSettings() {
            const savedSettings = localStorage.getItem('emdrAppSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    emdrAppState.animationSpeed = settings.animationSpeed || 2.0;
                    emdrAppState.targetSpeed = settings.animationSpeed || 2.0;
                    emdrAppState.audioEnabled = settings.audioEnabled || false;
                    emdrAppState.showInfinityLine = settings.showInfinityLine !== undefined ? settings.showInfinityLine : true;
                    emdrAppState.leftFrequency = settings.leftFrequency || 600;
                    emdrAppState.rightFrequency = settings.rightFrequency || 800;
                    emdrAppState.infinityWidth = settings.infinityWidth || 650;
                    emdrAppState.infinityHeight = settings.infinityHeight || 500;
                    emdrAppState.randomAudioEnabled = settings.randomAudioEnabled || false;
                    emdrAppState.randomInterval = settings.randomInterval || 10;
                    emdrAppState.randomIntervalInfinity = settings.randomIntervalInfinity || 10;
                    emdrAppState.randomVariation = settings.randomVariation || 100;
                    emdrAppState.baseLeftFrequency = settings.baseLeftFrequency || 600;
                    emdrAppState.baseRightFrequency = settings.baseRightFrequency || 800;
                    emdrAppState.randomHeightEnabled = settings.randomHeightEnabled || false;
                    emdrAppState.baseInfinityHeight = settings.baseInfinityHeight || 500;
                } catch (e) {
                    console.log('Error loading settings:', e);
                }
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                animationSpeed: emdrAppState.animationSpeed,
                audioEnabled: emdrAppState.audioEnabled,
                showInfinityLine: emdrAppState.showInfinityLine,
                leftFrequency: emdrAppState.leftFrequency,
                rightFrequency: emdrAppState.rightFrequency,
                infinityWidth: emdrAppState.infinityWidth,
                infinityHeight: emdrAppState.infinityHeight,
                randomAudioEnabled: emdrAppState.randomAudioEnabled,
                randomInterval: emdrAppState.randomInterval,
                randomIntervalInfinity: emdrAppState.randomIntervalInfinity,
                randomVariation: emdrAppState.randomVariation,
                baseLeftFrequency: emdrAppState.baseLeftFrequency,
                baseRightFrequency: emdrAppState.baseRightFrequency,
                randomHeightEnabled: emdrAppState.randomHeightEnabled,
                baseInfinityHeight: emdrAppState.baseInfinityHeight
            };
            localStorage.setItem('emdrAppSettings', JSON.stringify(settings));
        }

        // Update UI elements with loaded settings
        function updateUIWithLoadedSettings() {
            // Update speed slider
            const speedSlider = document.getElementById('speed-test-slider');
            const speedValue = document.getElementById('speed-test-value');
            if (speedSlider && speedValue) {
                speedSlider.value = emdrAppState.animationSpeed.toFixed(1);
                speedValue.textContent = emdrAppState.animationSpeed.toFixed(1);
            }

            // Update audio button
            const audioBtn = document.getElementById('audio-btn');
            if (audioBtn) {
                if (emdrAppState.audioEnabled) {
                    audioBtn.classList.add('running');
                    audioBtn.textContent = 'Audio ON';
                } else {
                    audioBtn.classList.remove('running');
                    audioBtn.textContent = 'Audio';
                }
            }

            // Update infinity line button
            const lineBtn = document.getElementById('line-toggle-btn');
            if (lineBtn) {
                if (emdrAppState.showInfinityLine) {
                    lineBtn.classList.add('active');
                    lineBtn.textContent = '📏';
                } else {
                    lineBtn.classList.remove('active');
                    lineBtn.textContent = '🚫';
                }
            }

            // Update frequency sliders and values
            const leftFreqSlider = document.getElementById('leftFreqSlider');
            const leftFreqValue = document.getElementById('leftFreqValue');
            const rightFreqSlider = document.getElementById('rightFreqSlider');
            const rightFreqValue = document.getElementById('rightFreqValue');

            if (leftFreqSlider && leftFreqValue) {
                leftFreqSlider.value = emdrAppState.leftFrequency;
                leftFreqValue.textContent = emdrAppState.leftFrequency;
            }

            if (rightFreqSlider && rightFreqValue) {
                rightFreqSlider.value = emdrAppState.rightFrequency;
                rightFreqValue.textContent = emdrAppState.rightFrequency;
            }


            // Update random audio sliders
            const intervalSlider = document.getElementById('randomIntervalSlider');
            const intervalValue = document.getElementById('randomIntervalValue');
            const variationSlider = document.getElementById('randomVariationSlider');
            const variationValue = document.getElementById('randomVariationValue');

            if (intervalSlider && intervalValue) {
                intervalSlider.value = emdrAppState.randomInterval;
                intervalValue.textContent = emdrAppState.randomInterval;
            }

            if (variationSlider && variationValue) {
                variationSlider.value = emdrAppState.randomVariation;
                variationValue.textContent = emdrAppState.randomVariation;
            }


            // Update width and height sliders and values
            const widthSlider = document.getElementById('widthSlider');
            const widthValue = document.getElementById('widthValue');
            const heightSlider = document.getElementById('heightSlider');
            const heightValue = document.getElementById('heightValue');

            if (widthSlider && widthValue) {
                widthSlider.value = emdrAppState.infinityWidth;
                widthValue.textContent = emdrAppState.infinityWidth;
            }

            if (heightSlider && heightValue) {
                heightSlider.value = emdrAppState.infinityHeight;
                heightValue.textContent = emdrAppState.infinityHeight;
            }
            
            
            // Update Quick Settings dropdown sliders
            const leftFreqSliderMain = document.getElementById('leftFreqSlider-main');
            const rightFreqSliderMain = document.getElementById('rightFreqSlider-main');
            const randomIntervalSliderMain = document.getElementById('randomIntervalSlider-main');
            const randomVariationSliderMain = document.getElementById('randomVariationSlider-main');
            const widthSliderMain = document.getElementById('widthSlider-main');
            const heightSliderMain = document.getElementById('heightSlider-main');
            const randomIntervalInfinitySliderMain = document.getElementById('randomIntervalInfinitySlider-main');
            
            if (leftFreqSliderMain) leftFreqSliderMain.value = emdrAppState.leftFrequency;
            if (rightFreqSliderMain) rightFreqSliderMain.value = emdrAppState.rightFrequency;
            if (randomIntervalSliderMain) randomIntervalSliderMain.value = emdrAppState.randomInterval;
            if (randomVariationSliderMain) randomVariationSliderMain.value = emdrAppState.randomVariation;
            if (widthSliderMain) widthSliderMain.value = emdrAppState.infinityWidth;
            if (heightSliderMain) heightSliderMain.value = emdrAppState.infinityHeight;
            if (randomIntervalInfinitySliderMain) randomIntervalInfinitySliderMain.value = emdrAppState.randomIntervalInfinity;
            
            // Update Infinity section sliders
            const speedSliderInfinity = document.getElementById('speed-test-slider-infinity');
            const leftFreqSliderInfinity = document.getElementById('leftFreqSlider-infinity');
            const rightFreqSliderInfinity = document.getElementById('rightFreqSlider-infinity');
            const randomIntervalSliderInfinity = document.getElementById('randomIntervalSlider-infinity');
            const randomVariationSliderInfinity = document.getElementById('randomVariationSlider-infinity');
            const widthSliderInfinity = document.getElementById('widthSlider-infinity');
            const heightSliderInfinity = document.getElementById('heightSlider-infinity');
            
            if (speedSliderInfinity) speedSliderInfinity.value = emdrAppState.animationSpeed.toFixed(1);
            if (leftFreqSliderInfinity) leftFreqSliderInfinity.value = emdrAppState.leftFrequency;
            if (rightFreqSliderInfinity) rightFreqSliderInfinity.value = emdrAppState.rightFrequency;
            if (randomIntervalSliderInfinity) randomIntervalSliderInfinity.value = emdrAppState.randomInterval;
            if (randomVariationSliderInfinity) randomVariationSliderInfinity.value = emdrAppState.randomVariation;
            if (widthSliderInfinity) widthSliderInfinity.value = emdrAppState.infinityWidth;
            if (heightSliderInfinity) heightSliderInfinity.value = emdrAppState.infinityHeight;
        }

        // Animated Infinity Class
        class AnimatedInfinity {
            constructor(canvasId, options = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas size to match container
                this.resizeCanvas();
                
                this.centerX = options.centerX || this.canvas.width / 2;
                this.centerY = options.centerY || this.canvas.height / 2;
                this.size = options.size || Math.min(this.canvas.width, this.canvas.height) * 0.6; // Much bigger infinity loop
                this.width = options.width || 120; // Width of infinity loop
                this.height = options.height || 60; // Height of infinity loop
                this.speed = options.speed || 0.015; // Constant speed
                this.time = 0;
                this.isRunning = false;
                this.stopRequested = false;
                this.ballColor = '#ff6b6b';
                this.pathColor = 'rgba(255, 255, 255, 0.2)';
                
                // Audio tracking for infinity pattern
                this.lastXPosition = 0; // Track last time for phase detection
                
                this.animate = this.animate.bind(this);
                
                // Handle window resize
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.size = Math.min(this.canvas.width, this.canvas.height) * 0.6; // Much bigger infinity loop
            }
            
            getPointOnPath(t) {
                const scaledT = t * Math.PI * 2;
                
                // Fixed parametric equations for continuous infinity symbol (no gaps)
                const x = this.centerX + this.width * Math.sin(scaledT) / (1 + Math.cos(scaledT) * Math.cos(scaledT));
                const y = this.centerY + this.height * Math.sin(scaledT) * Math.cos(scaledT) / (1 + Math.cos(scaledT) * Math.cos(scaledT));
                
                return { x, y };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw full infinity path only if enabled
                if (emdrAppState.showInfinityLine) {
                this.ctx.beginPath();
                    const segments = 300; // Increased segments for better continuity
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                    const point = this.getPointOnPath(t);
                        if (i === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                this.ctx.strokeStyle = this.pathColor;
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                }
                
                // Draw moving ball
                const currentPoint = this.getPointOnPath(this.time);
                this.ctx.beginPath();
                this.ctx.arc(currentPoint.x, currentPoint.y, 36, 0, Math.PI * 2); // Twice the size
                
                // Create gradient for 3D ball effect
                const gradient = this.ctx.createRadialGradient(
                    currentPoint.x - 12, currentPoint.y - 12, 0,
                    currentPoint.x, currentPoint.y, 36
                );
                gradient.addColorStop(0, '#ff9999');
                gradient.addColorStop(0.6, this.ballColor);
                gradient.addColorStop(1, '#c44569');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // No shadow for crisp ball appearance
                this.ctx.fill();
            }
            
            start() {
                this.isRunning = true;
                this.stopRequested = false;
                this.lastTime = null; // Reset time tracking
                this.animate(performance.now());
            }
            
            stop() {
                this.stopRequested = true;
            }
            
            stopImmediately() {
                this.isRunning = false;
                this.stopRequested = false;
            }
            
            setBallColor(color) {
                this.ballColor = color;
            }
            
            setSize(newSize) {
                this.size = newSize;
            }
            
            scaleSize(factor) {
                this.size *= factor;
            }
            
            getSize() {
                return this.size;
            }
            
            setWidth(newWidth) {
                this.width = newWidth;
                this.draw(); // Redraw immediately to show changes
            }
            
            setHeight(newHeight) {
                this.height = newHeight;
                this.draw(); // Redraw immediately to show changes
            }
            
            getDimensions() {
                return { width: this.width, height: this.height };
            }
            
            animate(currentTime) {
                if (!this.isRunning) {
                    console.log('Infinity animation not running, exiting');
                    return;
                }
                
                // Time-based animation instead of frame-based
                if (!this.lastTime) this.lastTime = currentTime;
                const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;
                
                // Smooth speed transition
                const speedDifference = emdrAppState.targetSpeed - emdrAppState.animationSpeed;
                const speedTransitionRate = 2.0; // How fast to transition (higher = faster transition)
                emdrAppState.animationSpeed += speedDifference * speedTransitionRate * deltaTime;
                
                // Update infinity animation speed smoothly
                this.speed = 1.0 / emdrAppState.animationSpeed; // cycles per second
                
                // Update time based on actual elapsed time, not frames
                this.time += this.speed * deltaTime;
                
                // Audio triggers for infinity pattern - based on time phases
                // Audio triggers for infinity pattern - trigger when ball is at left/right extremes
                // With Math.sin(scaledT): t=0.0=center, t=0.25=left, t=0.5=center, t=0.75=right, t=1.0=center
                
                // Left trigger: when ball reaches left extreme (time crosses 0.25)
                if (this.time >= 0.25 && this.lastXPosition < 0.25) {
                    playRightBell(); // Play right bell when ball is at left extreme (swapped)
                }
                // Right trigger: when ball reaches right extreme (time crosses 0.75)
                if (this.time >= 0.75 && this.lastXPosition < 0.75) {
                    playLeftBell(); // Play left bell when ball is at right extreme (swapped)
                }
                
                // Update tracking for next frame
                this.lastXPosition = this.time;
                
                if (this.time >= 1) {
                    console.log('Infinity: Cycle complete, stopRequested:', this.stopRequested);
                    if (this.stopRequested) {
                        this.isRunning = false;
                        this.stopRequested = false;
                        this.time = 0;
                        
                        // IMPORTANT: Update global state
                        emdrAppState.isRunning = false;
                        emdrAppState.stopRequested = false;
                        
                        // Reset button text and class
                        const toggleBtn = document.getElementById('toggle-btn');
                        if (toggleBtn) {
                            toggleBtn.textContent = 'Start';
                            toggleBtn.classList.remove('running');
                            toggleBtn.disabled = false; // Re-enable button
                            toggleBtn.style.pointerEvents = 'auto'; // Ensure button is clickable
                        }
                        
                        return;
                    }
                    this.time = 0;
                    // Reset audio tracking for next cycle
                    this.lastXPosition = 0; // Start at time 0
                }
                
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        // Tibetan Bell Audio System with Stereo Channels
        let globalAudioContext = null;
        
        function getAudioContext() {
            if (!globalAudioContext) {
                globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Resume context if it's suspended (Safari requirement)
                if (globalAudioContext.state === 'suspended') {
                    globalAudioContext.resume();
                }
            }
            return globalAudioContext;
        }
        
        function createTibetanBellSound(frequency = 800, duration = 2000, channel = 'both') {
            const audioContext = getAudioContext();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const pannerNode = audioContext.createStereoPanner();
            
            // Connect nodes: oscillator -> gain -> panner -> destination
            oscillator.connect(gainNode);
            gainNode.connect(pannerNode);
            pannerNode.connect(audioContext.destination);
            
            // Set frequency and type for bell-like sound
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            // Set stereo panning
            if (channel === 'left') {
                pannerNode.pan.setValueAtTime(-1, audioContext.currentTime); // Full left
            } else if (channel === 'right') {
                pannerNode.pan.setValueAtTime(1, audioContext.currentTime); // Full right
            } else {
                pannerNode.pan.setValueAtTime(0, audioContext.currentTime); // Center
            }
            
            // Create bell-like envelope (quick attack, slow decay)
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(emdrAppState.audioVolume * 0.8, now + 0.01); // Quick attack
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration / 1000); // Slow decay
            
            // Start and stop
            oscillator.start(now);
            oscillator.stop(now + duration / 1000);
        }

        function playLeftBell() {
            console.log('playLeftBell called, audioEnabled:', emdrAppState.audioEnabled);
            if (emdrAppState.audioEnabled) {
                // Use configured frequency for left ear, played in left channel
                createTibetanBellSound(emdrAppState.leftFrequency, 1000, 'left');
                console.log('🔔 Left bell sound played (left channel)');
            } else {
                console.log('🔇 Audio disabled, left bell not played');
            }
        }

        function playRightBell() {
            console.log('playRightBell called, audioEnabled:', emdrAppState.audioEnabled);
            if (emdrAppState.audioEnabled) {
                // Use configured frequency for right ear, played in right channel
                createTibetanBellSound(emdrAppState.rightFrequency, 1000, 'right');
                console.log('🔔 Right bell sound played (right channel)');
            } else {
                console.log('🔇 Audio disabled, right bell not played');
            }
        }

        // Global variables
        let infinityAnimation = null;
        let horizontalAnimation = null;
        
        // Horizontal animation state
        let horizontalBallColor = '#ff6b6b';
        let horizontalIsStopping = false;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Check for URL speed parameter first (only if present)
            const urlParams = new URLSearchParams(window.location.search);
            const speedParam = urlParams.get('speed');
            if (speedParam) {
                const urlSpeed = parseFloat(speedParam);
                emdrAppState.animationSpeed = urlSpeed;
                emdrAppState.targetSpeed = urlSpeed;
            }
            
            // Load saved settings (this will override URL parameter if no URL parameter exists)
            loadSettings();
            
            // Initialize audio context on first user interaction (Safari requirement)
            document.addEventListener('click', function() {
                if (globalAudioContext && globalAudioContext.state === 'suspended') {
                    globalAudioContext.resume();
                }
            }, { once: true });
            // Initialize infinity animation
            infinityAnimation = new AnimatedInfinity('infinity-canvas', {
                speed: 1.0 / emdrAppState.animationSpeed, // cycles per second
                size: 60, // Match the size slider default
                width: emdrAppState.infinityWidth, // Use saved width
                height: emdrAppState.infinityHeight // Use saved height
            });
            
            // Don't draw infinity pattern on startup since we start in horizontal mode
            // Draw initial horizontal ball at start position
            drawHorizontalBallAtStart();
            
            setupEmdrAppSlider();
            
            // Update UI with loaded settings
            updateUIWithLoadedSettings();
            
            // Update all toggle states
            updateAllAudioToggles();
            updateAllInfinityLineToggles();
            updateAllRandomAudioToggles();
            updateAllRandomHeightToggles();
            
            // Update section title
            updateSectionTitle();
            
            // Setup dropdown controls
            setupDropdownControls();
            
            // Update all display values
            updateAllFrequencyDisplays();
            updateAllRandomIntervalDisplays();
            updateAllRandomIntervalInfinityDisplays();
            updateAllRandomVariationDisplays();
            updateAllWidthDisplays();
            updateAllHeightDisplays();
            
        });

        function setupEmdrAppSlider() {
                const slider = document.getElementById('speed-test-slider');
                const valueDisplay = document.getElementById('speed-test-value');
            
                if (slider && valueDisplay) {
                slider.addEventListener('input', function() {
                    // Set both target speed and animation speed
                    const sliderValue = parseFloat(this.value);
                    emdrAppState.animationSpeed = sliderValue; // Update the main speed value
                    emdrAppState.targetSpeed = sliderValue; // Set target speed for smooth transition
                    valueDisplay.textContent = sliderValue.toFixed(1);
                    saveSettings(); // Save speed setting
                    
                    // Don't immediately change speed - let the smooth transition handle it
                });
            }
        }


        // Helper function to setup sliders with sync
        function setupSliderWithSync(sliderId, valueId, callback) {
            console.log(`Setting up slider: ${sliderId} with value display: ${valueId}`);
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);
            
            console.log(`Slider ${sliderId}:`, slider ? 'Found' : 'NOT FOUND');
            console.log(`Value display ${valueId}:`, valueDisplay ? 'Found' : 'NOT FOUND');
            
            if (slider && valueDisplay) {
                console.log(`Successfully setting up event listener for ${sliderId}`);
                slider.addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    console.log(`Slider ${sliderId} input event: value = ${value}`);
                    valueDisplay.textContent = value;
                    callback(value);
                });
            } else {
                console.log(`Failed to setup ${sliderId} - missing elements`);
            }
        }

        // Update all frequency displays
        function updateAllFrequencyDisplays() {
            const leftDisplays = ['leftFreqValue', 'leftFreqValue-infinity', 'leftFreqValue-main'];
            const rightDisplays = ['rightFreqValue', 'rightFreqValue-infinity', 'rightFreqValue-main'];
            const leftSliders = ['leftFreqSlider-main', 'leftFreqSlider-infinity'];
            const rightSliders = ['rightFreqSlider-main', 'rightFreqSlider-infinity'];
            
            leftDisplays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.leftFrequency;
            });
            
            rightDisplays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.rightFrequency;
            });
            
            // Also update slider positions
            leftSliders.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = emdrAppState.leftFrequency;
            });
            
            rightSliders.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = emdrAppState.rightFrequency;
            });
        }

        // Update all random interval displays
        function updateAllRandomIntervalDisplays() {
            const displays = ['randomIntervalValue', 'randomIntervalValue-infinity', 'randomIntervalValue-settings', 'randomIntervalValue-main'];
            displays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.randomInterval;
            });
        }

        // Update all random interval infinity displays
        function updateAllRandomIntervalInfinityDisplays() {
            const displays = ['randomIntervalInfinityValue-main'];
            displays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.randomIntervalInfinity;
            });
        }

        // Update all random variation displays
        function updateAllRandomVariationDisplays() {
            const displays = ['randomVariationValue', 'randomVariationValue-infinity', 'randomVariationValue-main'];
            displays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.randomVariation;
            });
        }

        // Update all width displays
        function updateAllWidthDisplays() {
            const displays = ['widthValue', 'widthValue-infinity', 'widthValue-main'];
            const sliders = ['widthSlider-main', 'widthSlider-infinity'];
            
            displays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.infinityWidth;
            });
            
            sliders.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = emdrAppState.infinityWidth;
            });
        }

        // Update all height displays
        function updateAllHeightDisplays() {
            const displays = ['heightValue', 'heightValue-infinity', 'heightValue-main'];
            const sliders = ['heightSlider-main', 'heightSlider-infinity'];
            
            displays.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = emdrAppState.infinityHeight;
            });
            
            sliders.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.value = emdrAppState.infinityHeight;
            });
        }


        function toggleEmdrApp() {
            const toggleBtn = document.getElementById('toggle-btn');
            
            console.log('toggleEmdrApp called, isRunning:', emdrAppState.isRunning, 'isInfinityPattern:', emdrAppState.isInfinityPattern, 'button found:', !!toggleBtn);
            
            if (!toggleBtn || !infinityAnimation) return;
            
            if (emdrAppState.isRunning) {
                // Request stop and let animations handle their own stopping
                emdrAppState.stopRequested = true;
                toggleBtn.textContent = 'Stopping...';
                toggleBtn.disabled = true; // Disable button during stopping
                
                // Stop animations and reset positions
                if (emdrAppState.isInfinityPattern) {
                    infinityAnimation.setBallColor('#ff9999'); // Change to lighter red for stopping
                    infinityAnimation.stop(); // Request smooth stop at end of cycle
                } else {
                    // For horizontal, request smooth stop instead of immediate stop
                    horizontalBallColor = '#ff9999'; // Change to lighter red for stopping
                    // Don't call stopHorizontalAnimation() - let it do smooth return
                }
                
            } else {
                console.log('Starting animation, isInfinityPattern:', emdrAppState.isInfinityPattern);
                // Start the animation
                emdrAppState.isRunning = true;
                emdrAppState.stopRequested = false;
                
                // Reset ball color
                infinityAnimation.setBallColor('#ff6b6b');
                
                if (emdrAppState.isInfinityPattern) {
                    console.log('Starting INFINITY pattern with speed:', emdrAppState.animationSpeed);
                    // Update speed based on slider for infinity pattern (actual seconds)
                    infinityAnimation.speed = 1.0 / emdrAppState.animationSpeed; // cycles per second
                    infinityAnimation.start();
                } else {
                    console.log('Starting HORIZONTAL pattern with speed:', emdrAppState.animationSpeed);
                    // Reset horizontal ball color and stopping state
                    horizontalBallColor = '#ff6b6b';
                    horizontalIsStopping = false;
                    startHorizontalAnimation();
                }
                
                // Update button state
                toggleBtn.classList.add('running');
                toggleBtn.textContent = 'Stop';
            }
        }

        // Monitor animation cycles to stop at start position
        function checkForStopAtStart() {
            const ball = document.getElementById('bouncy-ball');
            const toggleBtn = document.getElementById('toggle-btn');
            
            if (!ball || !emdrAppState.isRunning || !emdrAppState.stopRequested) return;
            
            // Get current position
            const ballRect = ball.getBoundingClientRect();
            const containerRect = ball.parentElement.getBoundingClientRect();
            const currentLeft = ballRect.left - containerRect.left;
            const currentTop = ballRect.top - containerRect.top;
            
            let shouldStop = false;
            
            if (emdrAppState.isInfinityPattern) {
                // For infinity pattern, stop when ball is near the starting position (top of infinity)
                // Check if ball is near the starting position (50% left, 40% top)
                const startLeft = containerRect.width * 0.5;
                const startTop = containerRect.height * 0.4;
                const distanceFromStart = Math.sqrt(
                    Math.pow(currentLeft - startLeft, 2) + Math.pow(currentTop - startTop, 2)
                );
                shouldStop = distanceFromStart < 40; // Within 40px of start position
            } else {
                // For horizontal pattern, stop when ball is near left edge
                shouldStop = currentLeft < 40; // Adjusted for new positioning
            }
            
            if (shouldStop) {
                emdrAppState.isRunning = false;
                emdrAppState.stopRequested = false;
                
                ball.classList.remove('animating', 'infinity', 'stopping');
                ball.style.setProperty('--animation-duration', '');
                
                // Reset to appropriate start position
                if (emdrAppState.isInfinityPattern) {
                    ball.style.left = '50%';
                    ball.style.top = '40%';
                } else {
                    ball.style.left = '30px';
                    ball.style.top = '50%';
                }
                
                // Update button state
                toggleBtn.classList.remove('running');
                toggleBtn.textContent = 'Start';
                toggleBtn.disabled = false; // Re-enable button
            }
        }

        // Check for stop condition every 100ms during animation
        let animationCheckInterval = null;
        
        function startAnimationCheck() {
            if (animationCheckInterval) clearInterval(animationCheckInterval);
            animationCheckInterval = setInterval(checkForStopAtStart, 100);
        }
        
        function stopAnimationCheck() {
            if (animationCheckInterval) {
                clearInterval(animationCheckInterval);
                animationCheckInterval = null;
            }
        }

        function togglePattern() {
            const patternBtn = document.getElementById('pattern-btn');
            const toggleBtn = document.getElementById('toggle-btn');
            
            if (!patternBtn || !toggleBtn) return;
            
            // Stop any running animation and reset to fresh start state
            if (emdrAppState.isRunning) {
                // Stop current animation
                if (emdrAppState.isInfinityPattern) {
                    infinityAnimation.stopImmediately(); // Force immediate stop
                    // Clear infinity canvas immediately
                    const canvas = document.getElementById('infinity-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                } else {
                    stopHorizontalAnimation();
                }
                
                // Reset state to fresh start
                emdrAppState.isRunning = false;
                emdrAppState.stopRequested = false;
                toggleBtn.textContent = 'Start';
                toggleBtn.classList.remove('running');
                toggleBtn.disabled = false;
                toggleBtn.style.pointerEvents = 'auto'; // Ensure button is clickable
            }
            
            // Toggle pattern
            emdrAppState.isInfinityPattern = !emdrAppState.isInfinityPattern;
            
            // Restart random frequency changes with correct interval for new pattern
            if (emdrAppState.randomAudioEnabled) {
                startRandomFrequencyChanges();
            }
            
            // Update section title
            updateSectionTitle();
            
            // Update dropdown visibility
            updateDropdownVisibility();
            
            // Update button text and style
            if (emdrAppState.isInfinityPattern) {
                patternBtn.textContent = '↔ Pattern';
                patternBtn.classList.add('running');
                // Show infinity pattern (static)
                infinityAnimation.draw();
                
                // Start random height changes if enabled
                if (emdrAppState.randomHeightEnabled) {
                    startRandomHeightChanges();
                }
            } else {
                patternBtn.textContent = '∞ Pattern';
                patternBtn.classList.remove('running');
                // Clear infinity canvas first, then show horizontal ball at start position
                const canvas = document.getElementById('infinity-canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawHorizontalBallAtStart();
                
                // Stop random height changes when switching to horizontal mode
                stopRandomHeightChanges();
            }
        }



        // Random frequency change functionality
        let randomFrequencyInterval = null;
        let randomHeightInterval = null;

        function startRandomFrequencyChanges() {
            if (randomFrequencyInterval) {
                clearInterval(randomFrequencyInterval);
            }
            
            // Use different intervals for horizontal vs infinity patterns
            const currentInterval = emdrAppState.isInfinityPattern ? 
                emdrAppState.randomIntervalInfinity : emdrAppState.randomInterval;
            
            randomFrequencyInterval = setInterval(() => {
                if (emdrAppState.randomAudioEnabled && emdrAppState.audioEnabled) {
                    changeRandomFrequencies();
                }
            }, currentInterval * 1000);
        }

        function stopRandomFrequencyChanges() {
            if (randomFrequencyInterval) {
                clearInterval(randomFrequencyInterval);
                randomFrequencyInterval = null;
            }
        }

        function changeRandomFrequencies() {
            // Calculate random variations for both frequencies
            const leftVariation = (Math.random() - 0.5) * 2 * emdrAppState.randomVariation;
            const rightVariation = (Math.random() - 0.5) * 2 * emdrAppState.randomVariation;
            
            // Apply variations to base frequencies
            let newLeftFreq = emdrAppState.baseLeftFrequency + leftVariation;
            let newRightFreq = emdrAppState.baseRightFrequency + rightVariation;
            
            // Clamp to 300-1000 Hz range
            newLeftFreq = Math.max(300, Math.min(1000, newLeftFreq));
            newRightFreq = Math.max(300, Math.min(1000, newRightFreq));
            
            // Update frequencies
            emdrAppState.leftFrequency = Math.round(newLeftFreq);
            emdrAppState.rightFrequency = Math.round(newRightFreq);
            
            // Update UI display
            updateFrequencyDisplay();
            
            console.log(`🎲 Random frequencies: L=${emdrAppState.leftFrequency}Hz, R=${emdrAppState.rightFrequency}Hz`);
        }

        function updateFrequencyDisplay() {
            // Call the comprehensive update function that updates all frequency displays
            updateAllFrequencyDisplays();
        }

        function startRandomHeightChanges() {
            if (randomHeightInterval) {
                clearInterval(randomHeightInterval);
            }
            
            // Track last height change time to respect the interval
            let lastHeightChangeTime = Date.now();
            
            randomHeightInterval = setInterval(() => {
                if (emdrAppState.randomHeightEnabled && emdrAppState.isInfinityPattern && infinityAnimation) {
                    const now = Date.now();
                    const timeSinceLastChange = (now - lastHeightChangeTime) / 1000; // seconds
                    
                    // Only check for center passage if enough time has passed since last change
                    if (timeSinceLastChange >= emdrAppState.randomIntervalInfinity) {
                        // Only change height when ball is near center (time close to 0.0)
                        const time = infinityAnimation.time;
                        const timeFromCenter = Math.min(time, 1.0 - time); // Distance from 0.0 or 1.0 (both are center)
                        
                        // Change height when ball is within 5% of center (0.05 = 5% of cycle)
                        if (timeFromCenter < 0.05) {
                            changeRandomHeight();
                            lastHeightChangeTime = now;
                            console.log(`📊 Random height changed at time ${time.toFixed(3)} (near center)`);
                        }
                    }
                }
            }, 100); // Check every 100ms for smooth detection
        }

        function stopRandomHeightChanges() {
            if (randomHeightInterval) {
                clearInterval(randomHeightInterval);
                randomHeightInterval = null;
            }
        }

        function changeRandomHeight() {
            // Use the standard height range from sliders (150-500)
            const minHeight = 150;
            const maxHeight = 500;
            
            // Generate random height within the slider range
            const randomHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
            
            // Update height
            emdrAppState.infinityHeight = randomHeight;
            
            // Update UI display
            updateAllHeightDisplays();
            
            // Update infinity animation with new height
            updateInfinityAnimation();
            
            console.log(`📊 Random height: ${randomHeight}`);
        }

        function updateHeightDisplay() {
            // Call the comprehensive update function that updates all height displays
            updateAllHeightDisplays();
        }

        function updateInfinityAnimation() {
            if (infinityAnimation && emdrAppState.isInfinityPattern) {
                infinityAnimation.setWidth(emdrAppState.infinityWidth);
                infinityAnimation.setHeight(emdrAppState.infinityHeight);
                // No need to call draw() since setWidth and setHeight already call it
            }
        }

        function easeInOut(t) {
            // Gentler ease-in-out for smoother, less aggressive acceleration/deceleration
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function startHorizontalAnimation() {
            console.log('🚀 Starting horizontal animation function');
            // Create a simple horizontal animation using canvas
            const canvas = document.getElementById('infinity-canvas');
            const ctx = canvas.getContext('2d');
            
            let position = 0;
            let direction = 1;
            const ballRadius = 36; // Twice the size to match infinity pattern
            // Initial speed will be calculated in the animate function based on slider value
            
            let lastTime = null;
            let cycleStartTime = null;
            let lastEasedProgress = 0;
            
            function animate(currentTime) {
                if (!emdrAppState.isRunning || emdrAppState.isInfinityPattern) {
                    if (!emdrAppState.isRunning) console.log('Horizontal: Animation not running, exiting');
                    if (emdrAppState.isInfinityPattern) console.log('Horizontal: Infinity pattern selected, exiting');
                    return;
                }
                
                
                // Debug: Log position and stopRequested status every 60 frames (roughly once per second)
                if (Math.floor(currentTime / 1000) !== Math.floor((currentTime - 16) / 1000)) {
                    console.log('Horizontal: Position:', position, 'stopRequested:', emdrAppState.stopRequested, 'direction:', direction);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Time-based animation with ease-in-out
                if (!lastTime) {
                    lastTime = currentTime;
                    cycleStartTime = currentTime;
                }
                const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
                lastTime = currentTime;
                
                // Smooth speed transition for horizontal animation
                const speedDifference = emdrAppState.targetSpeed - emdrAppState.animationSpeed;
                const speedTransitionRate = 2.0; // How fast to transition (higher = faster transition)
                emdrAppState.animationSpeed += speedDifference * speedTransitionRate * deltaTime;
                
                // Calculate cycle progress
                const cycleDuration = emdrAppState.animationSpeed; // seconds for full cycle
                const cycleElapsed = (currentTime - cycleStartTime) / 1000; // seconds elapsed
                const cycleProgress = (cycleElapsed % cycleDuration) / cycleDuration; // 0 to 1
                
                // Update position based on eased progress
                const canvasWidth = canvas.width;
                
                // Apply ease-in-out to each half of the movement separately
                let easedProgress;
                if (cycleProgress <= 0.5) {
                    // First half: left to center to right (0.0 → 0.5)
                    const halfProgress = cycleProgress * 2; // 0.0 → 1.0
                    const easedHalfProgress = easeInOut(halfProgress); // Apply easing to this half
                    easedProgress = easedHalfProgress; // For stopping logic
                    position = ballRadius + (canvasWidth - ballRadius * 2) * easedHalfProgress;
                } else {
                    // Second half: right to center to left (0.5 → 1.0)
                    const halfProgress = (cycleProgress - 0.5) * 2; // 0.0 → 1.0
                    const easedHalfProgress = easeInOut(halfProgress); // Apply easing to this half
                    easedProgress = 1.0 - easedHalfProgress; // For stopping logic (inverted for second half)
                    position = canvasWidth - ballRadius - (canvasWidth - ballRadius * 2) * easedHalfProgress;
                }
                
                // Audio triggers based on cycle progress
                // When cycleProgress is 0.5, ball is at right edge; when 0.0 or 1.0, ball is at left edge
                const wasAtRight = lastEasedProgress > 0.4 && lastEasedProgress < 0.6;
                const isAtLeft = cycleProgress < 0.1 || cycleProgress > 0.9;
                const wasAtLeft = lastEasedProgress < 0.1 || lastEasedProgress > 0.9;
                const isAtRight = cycleProgress > 0.4 && cycleProgress < 0.6;
                
                // Left trigger: when ball reaches left edge
                if (isAtLeft && !wasAtLeft) {
                    playLeftBell();
                }
                // Right trigger: when ball reaches right edge
                if (isAtRight && !wasAtRight) {
                    playRightBell();
                }
                
                // Store for next frame
                lastEasedProgress = cycleProgress;
                
                // Check if we should stop (when stop is requested and ball is near left edge)
                // Use cycleProgress for reliable stopping detection
                if (emdrAppState.stopRequested && (cycleProgress < 0.02 || cycleProgress > 0.98)) {
                    // Stop when ball reaches left edge - draw the ball at its final position first
                    horizontalIsStopping = false;
                    horizontalBallColor = '#ff6b6b'; // Reset to normal color
                    
                    // Draw ball at final position before stopping
                    ctx.beginPath();
                    ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                    
                    // Create gradient for 3D ball effect
                    const gradient = ctx.createRadialGradient(
                        position - 12, canvas.height / 2 - 12, 0,
                        position, canvas.height / 2, ballRadius
                    );
                    gradient.addColorStop(0, '#ff9999');
                    gradient.addColorStop(0.6, horizontalBallColor);
                    gradient.addColorStop(1, '#c44569');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // IMPORTANT: Reset global state
                    emdrAppState.isRunning = false;
                    emdrAppState.stopRequested = false;
                    
                    // Reset button text and class
                    const toggleBtn = document.getElementById('toggle-btn');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'Start';
                        toggleBtn.classList.remove('running');
                        toggleBtn.disabled = false; // Re-enable button
                        toggleBtn.style.pointerEvents = 'auto'; // Ensure button is clickable
                    }
                    
                    return; // Stop the animation
                }
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                
                // Create gradient for 3D ball effect
                const gradient = ctx.createRadialGradient(
                    position - 12, canvas.height / 2 - 12, 0,
                    position, canvas.height / 2, ballRadius
                );
                gradient.addColorStop(0, horizontalIsStopping ? '#ffaaaa' : '#ff9999');
                gradient.addColorStop(0.6, horizontalBallColor);
                gradient.addColorStop(1, horizontalIsStopping ? '#ff8888' : '#c44569');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // No shadow for crisp ball appearance
                ctx.fill();
                
                horizontalAnimation = requestAnimationFrame(animate);
            }
            
            console.log('🎬 Starting horizontal animate loop');
            animate(performance.now());
        }

        function stopHorizontalAnimation() {
            if (horizontalAnimation) {
                cancelAnimationFrame(horizontalAnimation);
                horizontalAnimation = null;
            }
        }

        function drawHorizontalBallAtStart() {
            // Draw horizontal ball at start position (left edge)
            const canvas = document.getElementById('infinity-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const ballRadius = 36; // Twice the size to match updated horizontal animation
            const position = ballRadius; // Start position at left edge
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ball at start position
            ctx.beginPath();
            ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
            
            // Create gradient for 3D ball effect (same as horizontal animation)
            const gradient = ctx.createRadialGradient(
                position - 12, canvas.height / 2 - 12, 0,
                position, canvas.height / 2, ballRadius
            );
            gradient.addColorStop(0, '#ff9999');
            gradient.addColorStop(0.6, '#ff6b6b');
            gradient.addColorStop(1, '#c44569');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // No shadow for crisp ball appearance
            ctx.beginPath();
            ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                toggleSpeedTest();
            } else if (event.code === 'Escape') {
                window.close();
            }
        });

        // Handle window close
        window.addEventListener('beforeunload', function() {
            stopAnimationCheck();
            if (emdrAppState.isRunning) {
                emdrAppState.isRunning = false;
                emdrAppState.stopRequested = false;
            }
        });
    </script>
</body>
</html>
