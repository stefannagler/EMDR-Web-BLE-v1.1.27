<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMDR Speed Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 5px;
            padding-top: 2vh;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
        }

        .title {
            text-align: center;
            color: white;
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .speed-test-controls {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 200px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            flex-wrap: wrap;
            gap: 40px; /* Fixed gap between speed slider and buttons */
        }

        .speed-test-slider-group {
            flex: 0 0 300px; /* Fixed width, no grow/shrink */
        }

        .speed-test-slider-group label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 12px;
            display: block;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .speed-test-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .speed-test-btn {
            padding: 14px 28px;
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.3), rgba(78, 205, 196, 0.1));
            border: 2px solid rgba(78, 205, 196, 0.6);
            border-radius: 16px;
            color: #4ecdc4;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 140px;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 6px 20px rgba(78, 205, 196, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .speed-test-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .speed-test-btn:hover::before {
            left: 100%;
        }

        .speed-test-btn:hover {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: #4ecdc4;
            transform: translateY(-3px);
            box-shadow: 
                0 8px 25px rgba(78, 205, 196, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .speed-test-btn:active {
            transform: translateY(-1px);
            box-shadow: 
                0 4px 15px rgba(78, 205, 196, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .speed-test-btn.running {
            background: linear-gradient(145deg, rgba(255, 107, 107, 0.3), rgba(255, 107, 107, 0.1));
            border-color: rgba(255, 107, 107, 0.6);
            color: #ff6b6b;
            box-shadow: 
                0 6px 20px rgba(255, 107, 107, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .speed-test-btn.running:hover {
            background: linear-gradient(145deg, rgba(255, 107, 107, 0.4), rgba(255, 107, 107, 0.2));
            border-color: #ff6b6b;
            box-shadow: 
                0 8px 25px rgba(255, 107, 107, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        }

        .speed-test-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Bouncy Ball Animation */
        .bouncy-ball-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            margin-top: 20px;
            margin-bottom: 0px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #infinity-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .size-controls {
            display: flex;
            flex-direction: row;
            justify-content: flex-end;
            gap: 20px;
            margin-top: 0;
            padding: 0;
            background: none;
            border: none;
            height: auto;
            box-sizing: border-box;
        }
        
        .size-controls .speed-test-slider-group {
            flex: 0 0 120px; /* Fixed width for each slider */
        }
        
        .line-toggle-btn {
            padding: 8px 12px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 40px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .line-toggle-btn:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }
        
        .line-toggle-btn.active {
            background: linear-gradient(145deg, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.2));
            border-color: rgba(78, 205, 196, 0.6);
            color: #4ecdc4;
        }

        .bouncy-ball {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ee5a52, #c44569);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: left 3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 2s ease;
            user-select: none;
            box-shadow: 
                0 6px 20px rgba(255, 107, 107, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .bouncy-ball.fading {
            opacity: 0 !important;
            transition: opacity 1.5s ease !important;
        }

        .bouncy-ball.returning {
            opacity: 0 !important;
            left: 0 !important;
            transition: left 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
        }

        .bouncy-ball.reappearing {
            opacity: 1 !important;
            transition: opacity 0.5s ease !important;
        }

        .bouncy-ball.stopping {
            background: radial-gradient(circle at 30% 30%, #ff9999, #ff7777, #ff5555) !important;
            box-shadow: 
                0 6px 20px rgba(255, 153, 153, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2) !important;
            transition: background 0.5s ease, box-shadow 0.5s ease !important;
        }

        .bouncy-ball.animating {
            animation: bounceHorizontal var(--animation-duration, 2s) ease-in-out infinite;
            transition: none; /* Disable transition during animation */
        }

        .bouncy-ball.infinity {
            animation: infinityPath var(--animation-duration, 2s) ease-in-out infinite;
            transition: none; /* Disable transition during animation */
        }

        @keyframes bounceHorizontal {
            0% {
                left: 30px;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                left: calc(100% - 30px);
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                left: 30px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes bounceHorizontalStop {
            0% {
                left: var(--current-position, 0);
                transform: translateY(-50%) scale(1);
            }
            100% {
                left: 0;
                transform: translateY(-50%) scale(1);
            }
        }

        @keyframes infinityPath {
            0% {
                left: 50%;
                top: 40%;
                transform: translate(-50%, -50%) scale(1);
            }
            8.33% {
                left: 65%;
                top: 35%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            16.66% {
                left: 75%;
                top: 45%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            25% {
                left: 80%;
                top: 60%;
                transform: translate(-50%, -50%) scale(1.15);
            }
            33.33% {
                left: 75%;
                top: 75%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            41.66% {
                left: 65%;
                top: 80%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            50% {
                left: 50%;
                top: 85%;
                transform: translate(-50%, -50%) scale(1);
            }
            58.33% {
                left: 35%;
                top: 80%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            66.66% {
                left: 25%;
                top: 75%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            75% {
                left: 20%;
                top: 60%;
                transform: translate(-50%, -50%) scale(1.15);
            }
            83.33% {
                left: 25%;
                top: 45%;
                transform: translate(-50%, -50%) scale(1.1);
            }
            91.66% {
                left: 35%;
                top: 35%;
                transform: translate(-50%, -50%) scale(1.05);
            }
            100% {
                left: 50%;
                top: 40%;
                transform: translate(-50%, -50%) scale(1);
            }
        }


        .close-btn {
            position: fixed;
            top: 30px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .speed-test-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .speed-test-buttons {
                justify-content: center;
            }
            
            .bouncy-ball-container {
                height: 80px;
            }
            
            .bouncy-ball {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <button class="close-btn" onclick="window.close()" title="Close Tab">✕</button>
    
    <div class="container">
        <h1 class="title">⚡ EMDR Speed Test</h1>
        
        <div class="speed-test-controls">
            <div class="speed-test-slider-group">
                <label>Animation Speed: <span id="speed-test-value">2.0</span>s</label>
                <input type="range" id="speed-test-slider" min="1.0" max="3.0" step="0.1" value="2.0" class="slider">
            </div>
                <div class="speed-test-buttons">
                    <button class="speed-test-btn" id="toggle-btn" onclick="toggleSpeedTest()">Start</button>
                    <button class="speed-test-btn" id="pattern-btn" onclick="togglePattern()">∞ Pattern</button>
                    <button class="speed-test-btn" id="audio-btn" onclick="toggleAudio()">🔔 Audio</button>
                    
                    <div class="size-controls" id="size-controls" style="display: none;">
                        <div class="speed-test-slider-group">
                            <label>Width: <span id="widthValue">650</span></label>
                            <input type="range" id="widthSlider" min="300" max="800" value="650" class="slider">
                        </div>
                        <div class="speed-test-slider-group">
                            <label>Height: <span id="heightValue">500</span></label>
                            <input type="range" id="heightSlider" min="150" max="500" value="500" class="slider">
                        </div>
                        <button class="line-toggle-btn" id="line-toggle-btn" onclick="toggleInfinityLine()" title="Toggle Infinity Line">📏</button>
                    </div>
                </div>
        </div>
        
        <div class="bouncy-ball-container">
            <canvas id="infinity-canvas"></canvas>
        </div>
        
    </div>

    <script>
        // Speed Test State
        let speedTestState = {
            isRunning: false,
            animationSpeed: 2.0,
            targetSpeed: 2.0, // Target speed for smooth transitions
            stopRequested: false,
            isInfinityPattern: false,
            audioEnabled: false,
            audioVolume: 0.5,
            showInfinityLine: true // Show infinity line by default
        };

        // Animated Infinity Class
        class AnimatedInfinity {
            constructor(canvasId, options = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas size to match container
                this.resizeCanvas();
                
                this.centerX = options.centerX || this.canvas.width / 2;
                this.centerY = options.centerY || this.canvas.height / 2;
                this.size = options.size || Math.min(this.canvas.width, this.canvas.height) * 0.6; // Much bigger infinity loop
                this.width = options.width || 120; // Width of infinity loop
                this.height = options.height || 60; // Height of infinity loop
                this.speed = options.speed || 0.015; // Constant speed
                this.time = 0;
                this.isRunning = false;
                this.stopRequested = false;
                this.ballColor = '#ff6b6b';
                this.pathColor = 'rgba(255, 255, 255, 0.2)';
                
                // Audio tracking for infinity pattern
                this.lastXPosition = 0; // Track last time for phase detection
                
                this.animate = this.animate.bind(this);
                
                // Handle window resize
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
                this.size = Math.min(this.canvas.width, this.canvas.height) * 0.6; // Much bigger infinity loop
            }
            
            getPointOnPath(t) {
                const scaledT = t * Math.PI * 2;
                
                // Fixed parametric equations for continuous infinity symbol (no gaps)
                const x = this.centerX + this.width * Math.sin(scaledT) / (1 + Math.cos(scaledT) * Math.cos(scaledT));
                const y = this.centerY + this.height * Math.sin(scaledT) * Math.cos(scaledT) / (1 + Math.cos(scaledT) * Math.cos(scaledT));
                
                return { x, y };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw full infinity path only if enabled
                if (speedTestState.showInfinityLine) {
                    this.ctx.beginPath();
                    const segments = 300; // Increased segments for better continuity
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const point = this.getPointOnPath(t);
                        if (i === 0) {
                            this.ctx.moveTo(point.x, point.y);
                        } else {
                            this.ctx.lineTo(point.x, point.y);
                        }
                    }
                    this.ctx.strokeStyle = this.pathColor;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
                
                // Draw moving ball
                const currentPoint = this.getPointOnPath(this.time);
                this.ctx.beginPath();
                this.ctx.arc(currentPoint.x, currentPoint.y, 36, 0, Math.PI * 2); // Twice the size
                
                // Create gradient for 3D ball effect
                const gradient = this.ctx.createRadialGradient(
                    currentPoint.x - 12, currentPoint.y - 12, 0,
                    currentPoint.x, currentPoint.y, 36
                );
                gradient.addColorStop(0, '#ff9999');
                gradient.addColorStop(0.6, this.ballColor);
                gradient.addColorStop(1, '#c44569');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // No shadow for crisp ball appearance
                this.ctx.fill();
            }
            
            start() {
                this.isRunning = true;
                this.stopRequested = false;
                this.lastTime = null; // Reset time tracking
                this.animate(performance.now());
            }
            
            stop() {
                this.stopRequested = true;
            }
            
            stopImmediately() {
                this.isRunning = false;
                this.stopRequested = false;
            }
            
            setBallColor(color) {
                this.ballColor = color;
            }
            
            setSize(newSize) {
                this.size = newSize;
            }
            
            scaleSize(factor) {
                this.size *= factor;
            }
            
            getSize() {
                return this.size;
            }
            
            setWidth(newWidth) {
                this.width = newWidth;
                this.draw(); // Redraw immediately to show changes
            }
            
            setHeight(newHeight) {
                this.height = newHeight;
                this.draw(); // Redraw immediately to show changes
            }
            
            getDimensions() {
                return { width: this.width, height: this.height };
            }
            
            animate(currentTime) {
                if (!this.isRunning) {
                    console.log('Infinity animation not running, exiting');
                    return;
                }
                
                // Time-based animation instead of frame-based
                if (!this.lastTime) this.lastTime = currentTime;
                const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;
                
                // Smooth speed transition
                const speedDifference = speedTestState.targetSpeed - speedTestState.animationSpeed;
                const speedTransitionRate = 2.0; // How fast to transition (higher = faster transition)
                speedTestState.animationSpeed += speedDifference * speedTransitionRate * deltaTime;
                
                // Update infinity animation speed smoothly
                this.speed = 1.0 / speedTestState.animationSpeed; // cycles per second
                
                // Update time based on actual elapsed time, not frames
                this.time += this.speed * deltaTime;
                
                // Audio triggers for infinity pattern - based on time phases
                // Audio triggers for infinity pattern - trigger when ball is at left/right extremes
                // With Math.sin(scaledT): t=0.0=center, t=0.25=left, t=0.5=center, t=0.75=right, t=1.0=center
                
                // Left trigger: when ball reaches left extreme (time crosses 0.25)
                if (this.time >= 0.25 && this.lastXPosition < 0.25) {
                    playLeftBell(); // Play left bell when ball is at left extreme
                }
                // Right trigger: when ball reaches right extreme (time crosses 0.75)
                if (this.time >= 0.75 && this.lastXPosition < 0.75) {
                    playRightBell(); // Play right bell when ball is at right extreme
                }
                
                // Update tracking for next frame
                this.lastXPosition = this.time;
                
                if (this.time >= 1) {
                    console.log('Infinity: Cycle complete, stopRequested:', this.stopRequested);
                    if (this.stopRequested) {
                        this.isRunning = false;
                        this.stopRequested = false;
                        this.time = 0;
                        
                        // IMPORTANT: Update global state
                        speedTestState.isRunning = false;
                        speedTestState.stopRequested = false;
                        
                        // Reset button text and class
                        const toggleBtn = document.getElementById('toggle-btn');
                        if (toggleBtn) {
                            toggleBtn.textContent = 'Start';
                            toggleBtn.classList.remove('running');
                            toggleBtn.disabled = false; // Re-enable button
                            toggleBtn.style.pointerEvents = 'auto'; // Ensure button is clickable
                        }
                        
                        return;
                    }
                    this.time = 0;
                    // Reset audio tracking for next cycle
                    this.lastXPosition = 0; // Start at time 0
                }
                
                this.draw();
                requestAnimationFrame(this.animate);
            }
        }

        // Tibetan Bell Audio System with Stereo Channels
        function createTibetanBellSound(frequency = 800, duration = 2000, channel = 'both') {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const pannerNode = audioContext.createStereoPanner();
            
            // Connect nodes: oscillator -> gain -> panner -> destination
            oscillator.connect(gainNode);
            gainNode.connect(pannerNode);
            pannerNode.connect(audioContext.destination);
            
            // Set frequency and type for bell-like sound
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            // Set stereo panning
            if (channel === 'left') {
                pannerNode.pan.setValueAtTime(-1, audioContext.currentTime); // Full left
            } else if (channel === 'right') {
                pannerNode.pan.setValueAtTime(1, audioContext.currentTime); // Full right
            } else {
                pannerNode.pan.setValueAtTime(0, audioContext.currentTime); // Center
            }
            
            // Create bell-like envelope (quick attack, slow decay)
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(speedTestState.audioVolume * 0.8, now + 0.01); // Quick attack
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration / 1000); // Slow decay
            
            // Start and stop
            oscillator.start(now);
            oscillator.stop(now + duration / 1000);
        }

        function playLeftBell() {
            if (speedTestState.audioEnabled) {
                // Lower frequency for left ear, played in left channel
                createTibetanBellSound(600, 300, 'left');
                console.log('🔔 Left bell sound played (left channel)');
            }
        }

        function playRightBell() {
            if (speedTestState.audioEnabled) {
                // Higher frequency for right ear, played in right channel
                createTibetanBellSound(1000, 300, 'right');
                console.log('🔔 Right bell sound played (right channel)');
            }
        }

        // Global variables
        let infinityAnimation = null;
        let horizontalAnimation = null;
        
        // Horizontal animation state
        let horizontalBallColor = '#ff6b6b';
        let horizontalIsStopping = false;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize infinity animation
            infinityAnimation = new AnimatedInfinity('infinity-canvas', {
                speed: 1.0 / speedTestState.animationSpeed, // cycles per second
                size: 60, // Match the size slider default
                width: 650, // Updated default width
                height: 500 // Updated default height
            });
            
            // Don't draw infinity pattern on startup since we start in horizontal mode
            // Draw initial horizontal ball at start position
            drawHorizontalBallAtStart();
            // Get speed from URL parameter if available
            const urlParams = new URLSearchParams(window.location.search);
            const speedParam = urlParams.get('speed');
            if (speedParam) {
                const urlSpeed = parseFloat(speedParam);
                speedTestState.animationSpeed = urlSpeed;
                const slider = document.getElementById('speed-test-slider');
                const valueDisplay = document.getElementById('speed-test-value');
                if (slider && valueDisplay) {
                    // Set slider to match the URL speed parameter directly
                    slider.value = urlSpeed.toFixed(1);
                    valueDisplay.textContent = speedParam;
                }
            }
            
            setupSpeedTestSlider();
            setupSizeControls();
        });

        function setupSpeedTestSlider() {
            const slider = document.getElementById('speed-test-slider');
            const valueDisplay = document.getElementById('speed-test-value');
            
            if (slider && valueDisplay) {
                slider.addEventListener('input', function() {
                    // Set target speed for smooth transition
                    const sliderValue = parseFloat(this.value);
                    speedTestState.targetSpeed = sliderValue; // Set target speed
                    valueDisplay.textContent = sliderValue.toFixed(1);
                    
                    // Don't immediately change speed - let the smooth transition handle it
                });
            }
        }

        function setupSizeControls() {
            const widthSlider = document.getElementById('widthSlider');
            const heightSlider = document.getElementById('heightSlider');
            const widthValue = document.getElementById('widthValue');
            const heightValue = document.getElementById('heightValue');
            
            // Width controls
            if (widthSlider && widthValue) {
                widthSlider.addEventListener('input', (e) => {
                    const newWidth = parseInt(e.target.value);
                    if (infinityAnimation) {
                        infinityAnimation.setWidth(newWidth);
                    }
                    widthValue.textContent = newWidth;
                });
            }
            
            // Height controls
            if (heightSlider && heightValue) {
                heightSlider.addEventListener('input', (e) => {
                    const newHeight = parseInt(e.target.value);
                    if (infinityAnimation) {
                        infinityAnimation.setHeight(newHeight);
                    }
                    heightValue.textContent = newHeight;
                });
            }
        }

        function toggleSpeedTest() {
            const toggleBtn = document.getElementById('toggle-btn');
            
            console.log('toggleSpeedTest called, isRunning:', speedTestState.isRunning, 'isInfinityPattern:', speedTestState.isInfinityPattern, 'button found:', !!toggleBtn);
            
            if (!toggleBtn || !infinityAnimation) return;
            
            if (speedTestState.isRunning) {
                // Request stop and let animations handle their own stopping
                speedTestState.stopRequested = true;
                toggleBtn.textContent = 'Stopping...';
                toggleBtn.disabled = true; // Disable button during stopping
                
                // Stop animations and reset positions
                if (speedTestState.isInfinityPattern) {
                    infinityAnimation.setBallColor('#ff9999'); // Change to lighter red for stopping
                    infinityAnimation.stop(); // Request smooth stop at end of cycle
                } else {
                    // For horizontal, request smooth stop instead of immediate stop
                    horizontalBallColor = '#ff9999'; // Change to lighter red for stopping
                    // Don't call stopHorizontalAnimation() - let it do smooth return
                }
                
            } else {
                console.log('Starting animation, isInfinityPattern:', speedTestState.isInfinityPattern);
                // Start the animation
                speedTestState.isRunning = true;
                speedTestState.stopRequested = false;
                
                // Reset ball color
                infinityAnimation.setBallColor('#ff6b6b');
                
                if (speedTestState.isInfinityPattern) {
                    console.log('Starting INFINITY pattern with speed:', speedTestState.animationSpeed);
                    // Update speed based on slider for infinity pattern (actual seconds)
                    infinityAnimation.speed = 1.0 / speedTestState.animationSpeed; // cycles per second
                    infinityAnimation.start();
                } else {
                    console.log('Starting HORIZONTAL pattern with speed:', speedTestState.animationSpeed);
                    // Reset horizontal ball color and stopping state
                    horizontalBallColor = '#ff6b6b';
                    horizontalIsStopping = false;
                    startHorizontalAnimation();
                }
                
                // Update button state
                toggleBtn.classList.add('running');
                toggleBtn.textContent = 'Stop';
            }
        }

        // Monitor animation cycles to stop at start position
        function checkForStopAtStart() {
            const ball = document.getElementById('bouncy-ball');
            const toggleBtn = document.getElementById('toggle-btn');
            
            if (!ball || !speedTestState.isRunning || !speedTestState.stopRequested) return;
            
            // Get current position
            const ballRect = ball.getBoundingClientRect();
            const containerRect = ball.parentElement.getBoundingClientRect();
            const currentLeft = ballRect.left - containerRect.left;
            const currentTop = ballRect.top - containerRect.top;
            
            let shouldStop = false;
            
            if (speedTestState.isInfinityPattern) {
                // For infinity pattern, stop when ball is near the starting position (top of infinity)
                // Check if ball is near the starting position (50% left, 40% top)
                const startLeft = containerRect.width * 0.5;
                const startTop = containerRect.height * 0.4;
                const distanceFromStart = Math.sqrt(
                    Math.pow(currentLeft - startLeft, 2) + Math.pow(currentTop - startTop, 2)
                );
                shouldStop = distanceFromStart < 40; // Within 40px of start position
            } else {
                // For horizontal pattern, stop when ball is near left edge
                shouldStop = currentLeft < 40; // Adjusted for new positioning
            }
            
            if (shouldStop) {
                speedTestState.isRunning = false;
                speedTestState.stopRequested = false;
                
                ball.classList.remove('animating', 'infinity', 'stopping');
                ball.style.setProperty('--animation-duration', '');
                
                // Reset to appropriate start position
                if (speedTestState.isInfinityPattern) {
                    ball.style.left = '50%';
                    ball.style.top = '40%';
                } else {
                    ball.style.left = '30px';
                    ball.style.top = '50%';
                }
                
                // Update button state
                toggleBtn.classList.remove('running');
                toggleBtn.textContent = 'Start';
                toggleBtn.disabled = false; // Re-enable button
            }
        }

        // Check for stop condition every 100ms during animation
        let animationCheckInterval = null;
        
        function startAnimationCheck() {
            if (animationCheckInterval) clearInterval(animationCheckInterval);
            animationCheckInterval = setInterval(checkForStopAtStart, 100);
        }
        
        function stopAnimationCheck() {
            if (animationCheckInterval) {
                clearInterval(animationCheckInterval);
                animationCheckInterval = null;
            }
        }

        function togglePattern() {
            const patternBtn = document.getElementById('pattern-btn');
            const toggleBtn = document.getElementById('toggle-btn');
            
            if (!patternBtn || !toggleBtn) return;
            
            // Stop any running animation and reset to fresh start state
            if (speedTestState.isRunning) {
                // Stop current animation
                if (speedTestState.isInfinityPattern) {
                    infinityAnimation.stopImmediately(); // Force immediate stop
                    // Clear infinity canvas immediately
                    const canvas = document.getElementById('infinity-canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                } else {
                    stopHorizontalAnimation();
                }
                
                // Reset state to fresh start
                speedTestState.isRunning = false;
                speedTestState.stopRequested = false;
                toggleBtn.textContent = 'Start';
                toggleBtn.classList.remove('running');
                toggleBtn.disabled = false;
                toggleBtn.style.pointerEvents = 'auto'; // Ensure button is clickable
            }
            
            // Toggle pattern
            speedTestState.isInfinityPattern = !speedTestState.isInfinityPattern;
            
            // Update button text and style
            if (speedTestState.isInfinityPattern) {
                patternBtn.textContent = '↔ Pattern';
                patternBtn.classList.add('running');
                // Show size controls for infinity pattern
                document.getElementById('size-controls').style.display = 'flex';
                // Show infinity pattern (static)
                infinityAnimation.draw();
            } else {
                patternBtn.textContent = '∞ Pattern';
                patternBtn.classList.remove('running');
                // Hide size controls for horizontal pattern
                document.getElementById('size-controls').style.display = 'none';
                // Clear infinity canvas first, then show horizontal ball at start position
                const canvas = document.getElementById('infinity-canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawHorizontalBallAtStart();
            }
        }

        function toggleAudio() {
            speedTestState.audioEnabled = !speedTestState.audioEnabled;
            const audioBtn = document.getElementById('audio-btn');
            if (audioBtn) {
                if (speedTestState.audioEnabled) {
                    audioBtn.classList.add('running');
                    audioBtn.textContent = '🔊 Audio';
                    console.log('🔊 Audio enabled - Tibetan bells will play for left/right movement');
                } else {
                    audioBtn.classList.remove('running');
                    audioBtn.textContent = '🔔 Audio';
                    console.log('🔇 Audio disabled');
                }
            }
        }

        function toggleInfinityLine() {
            speedTestState.showInfinityLine = !speedTestState.showInfinityLine;
            const lineBtn = document.getElementById('line-toggle-btn');
            if (lineBtn) {
                if (speedTestState.showInfinityLine) {
                    lineBtn.classList.add('active');
                    lineBtn.textContent = '📏';
                    console.log('📏 Infinity line shown');
                } else {
                    lineBtn.classList.remove('active');
                    lineBtn.textContent = '🚫';
                    console.log('🚫 Infinity line hidden');
                }
            }
            
            // Redraw infinity pattern if currently visible
            if (speedTestState.isInfinityPattern && infinityAnimation) {
                infinityAnimation.draw();
            }
        }

        function easeInOut(t) {
            // Gentler ease-in-out for smoother, less aggressive acceleration/deceleration
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function startHorizontalAnimation() {
            console.log('🚀 Starting horizontal animation function');
            // Create a simple horizontal animation using canvas
            const canvas = document.getElementById('infinity-canvas');
            const ctx = canvas.getContext('2d');
            
            let position = 0;
            let direction = 1;
            const ballRadius = 36; // Twice the size to match infinity pattern
            // Initial speed will be calculated in the animate function based on slider value
            
            let lastTime = null;
            let cycleStartTime = null;
            let lastEasedProgress = 0;
            
            function animate(currentTime) {
                if (!speedTestState.isRunning || speedTestState.isInfinityPattern) {
                    if (!speedTestState.isRunning) console.log('Horizontal: Animation not running, exiting');
                    if (speedTestState.isInfinityPattern) console.log('Horizontal: Infinity pattern selected, exiting');
                    return;
                }
                
                
                // Debug: Log position and stopRequested status every 60 frames (roughly once per second)
                if (Math.floor(currentTime / 1000) !== Math.floor((currentTime - 16) / 1000)) {
                    console.log('Horizontal: Position:', position, 'stopRequested:', speedTestState.stopRequested, 'direction:', direction);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Time-based animation with ease-in-out
                if (!lastTime) {
                    lastTime = currentTime;
                    cycleStartTime = currentTime;
                }
                const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
                lastTime = currentTime;
                
                // Smooth speed transition for horizontal animation
                const speedDifference = speedTestState.targetSpeed - speedTestState.animationSpeed;
                const speedTransitionRate = 2.0; // How fast to transition (higher = faster transition)
                speedTestState.animationSpeed += speedDifference * speedTransitionRate * deltaTime;
                
                // Calculate cycle progress
                const cycleDuration = speedTestState.animationSpeed; // seconds for full cycle
                const cycleElapsed = (currentTime - cycleStartTime) / 1000; // seconds elapsed
                const cycleProgress = (cycleElapsed % cycleDuration) / cycleDuration; // 0 to 1
                
                // Update position based on eased progress
                const canvasWidth = canvas.width;
                
                // Apply ease-in-out to each half of the movement separately
                let easedProgress;
                if (cycleProgress <= 0.5) {
                    // First half: left to center to right (0.0 → 0.5)
                    const halfProgress = cycleProgress * 2; // 0.0 → 1.0
                    const easedHalfProgress = easeInOut(halfProgress); // Apply easing to this half
                    easedProgress = easedHalfProgress; // For stopping logic
                    position = ballRadius + (canvasWidth - ballRadius * 2) * easedHalfProgress;
                } else {
                    // Second half: right to center to left (0.5 → 1.0)
                    const halfProgress = (cycleProgress - 0.5) * 2; // 0.0 → 1.0
                    const easedHalfProgress = easeInOut(halfProgress); // Apply easing to this half
                    easedProgress = 1.0 - easedHalfProgress; // For stopping logic (inverted for second half)
                    position = canvasWidth - ballRadius - (canvasWidth - ballRadius * 2) * easedHalfProgress;
                }
                
                // Audio triggers based on cycle progress
                // When cycleProgress is 0.5, ball is at right edge; when 0.0 or 1.0, ball is at left edge
                const wasAtRight = lastEasedProgress > 0.4 && lastEasedProgress < 0.6;
                const isAtLeft = cycleProgress < 0.1 || cycleProgress > 0.9;
                const wasAtLeft = lastEasedProgress < 0.1 || lastEasedProgress > 0.9;
                const isAtRight = cycleProgress > 0.4 && cycleProgress < 0.6;
                
                // Left trigger: when ball reaches left edge
                if (isAtLeft && !wasAtLeft) {
                    playLeftBell();
                }
                // Right trigger: when ball reaches right edge
                if (isAtRight && !wasAtRight) {
                    playRightBell();
                }
                
                // Store for next frame
                lastEasedProgress = cycleProgress;
                
                // Check if we should stop (when stop is requested and ball is near left edge)
                // Use cycleProgress for reliable stopping detection
                if (speedTestState.stopRequested && (cycleProgress < 0.02 || cycleProgress > 0.98)) {
                    // Stop when ball reaches left edge - draw the ball at its final position first
                    horizontalIsStopping = false;
                    horizontalBallColor = '#ff6b6b'; // Reset to normal color
                    
                    // Draw ball at final position before stopping
                    ctx.beginPath();
                    ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                    
                    // Create gradient for 3D ball effect
                    const gradient = ctx.createRadialGradient(
                        position - 12, canvas.height / 2 - 12, 0,
                        position, canvas.height / 2, ballRadius
                    );
                    gradient.addColorStop(0, '#ff9999');
                    gradient.addColorStop(0.6, horizontalBallColor);
                    gradient.addColorStop(1, '#c44569');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // IMPORTANT: Reset global state
                    speedTestState.isRunning = false;
                    speedTestState.stopRequested = false;
                    
                    // Reset button text and class
                    const toggleBtn = document.getElementById('toggle-btn');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'Start';
                        toggleBtn.classList.remove('running');
                        toggleBtn.disabled = false; // Re-enable button
                        toggleBtn.style.pointerEvents = 'auto'; // Ensure button is clickable
                    }
                    
                    return; // Stop the animation
                }
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
                
                // Create gradient for 3D ball effect
                const gradient = ctx.createRadialGradient(
                    position - 12, canvas.height / 2 - 12, 0,
                    position, canvas.height / 2, ballRadius
                );
                gradient.addColorStop(0, horizontalIsStopping ? '#ffaaaa' : '#ff9999');
                gradient.addColorStop(0.6, horizontalBallColor);
                gradient.addColorStop(1, horizontalIsStopping ? '#ff8888' : '#c44569');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // No shadow for crisp ball appearance
                ctx.fill();
                
                horizontalAnimation = requestAnimationFrame(animate);
            }
            
            console.log('🎬 Starting horizontal animate loop');
            animate(performance.now());
        }

        function stopHorizontalAnimation() {
            if (horizontalAnimation) {
                cancelAnimationFrame(horizontalAnimation);
                horizontalAnimation = null;
            }
        }

        function drawHorizontalBallAtStart() {
            // Draw horizontal ball at start position (left edge)
            const canvas = document.getElementById('infinity-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const ballRadius = 36; // Twice the size to match updated horizontal animation
            const position = ballRadius; // Start position at left edge
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ball at start position
            ctx.beginPath();
            ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
            
            // Create gradient for 3D ball effect (same as horizontal animation)
            const gradient = ctx.createRadialGradient(
                position - 12, canvas.height / 2 - 12, 0,
                position, canvas.height / 2, ballRadius
            );
            gradient.addColorStop(0, '#ff9999');
            gradient.addColorStop(0.6, '#ff6b6b');
            gradient.addColorStop(1, '#c44569');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // No shadow for crisp ball appearance
            ctx.beginPath();
            ctx.arc(position, canvas.height / 2, ballRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                toggleSpeedTest();
            } else if (event.code === 'Escape') {
                window.close();
            }
        });

        // Handle window close
        window.addEventListener('beforeunload', function() {
            stopAnimationCheck();
            if (speedTestState.isRunning) {
                speedTestState.isRunning = false;
                speedTestState.stopRequested = false;
            }
        });
    </script>
</body>
</html>
